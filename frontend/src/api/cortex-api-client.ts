//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

export class CortexApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return Success
     */
    reindex(): Promise<void> {
        let url_ = this.baseUrl + "/api/Admin/reindex";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReindex(_response);
        });
    }

    protected processReindex(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    reembed(): Promise<void> {
        let url_ = this.baseUrl + "/api/Admin/reembed";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReembed(_response);
        });
    }

    protected processReembed(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    health(): Promise<void> {
        let url_ = this.baseUrl + "/api/Admin/health";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHealth(_response);
        });
    }

    protected processHealth(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    reindex2(body: EmbedReindexRequest | undefined): Promise<EmbedReindexResponse> {
        let url_ = this.baseUrl + "/api/Admin/embed/reindex";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReindex2(_response);
        });
    }

    protected processReindex2(response: Response): Promise<EmbedReindexResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmbedReindexResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EmbedReindexResponse>(null as any);
    }

    /**
     * @return Success
     */
    stats(): Promise<EmbedStatsResponse> {
        let url_ = this.baseUrl + "/api/Admin/embed/stats";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStats(_response);
        });
    }

    protected processStats(response: Response): Promise<EmbedStatsResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmbedStatsResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EmbedStatsResponse>(null as any);
    }

    /**
     * @return Success
     */
    listNotes(): Promise<void> {
        let url_ = this.baseUrl + "/api/Cards/list-notes";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListNotes(_response);
        });
    }

    protected processListNotes(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    note(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Cards/note/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNote(_response);
        });
    }

    protected processNote(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param action (optional) 
     * @return Success
     */
    confirmDelete(action: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Cards/confirm-delete?";
        if (action === null)
            throw new globalThis.Error("The parameter 'action' cannot be null.");
        else if (action !== undefined)
            url_ += "action=" + encodeURIComponent("" + action) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processConfirmDelete(_response);
        });
    }

    protected processConfirmDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    tools(body: ChatToolsRequest | undefined): Promise<ChatToolsResponse> {
        let url_ = this.baseUrl + "/api/chat/tools";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTools(_response);
        });
    }

    protected processTools(response: Response): Promise<ChatToolsResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChatToolsResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ChatToolsResponse>(null as any);
    }

    /**
     * @return Success
     */
    toolsAll(): Promise<string[]> {
        let url_ = this.baseUrl + "/api/chat/tools";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processToolsAll(_response);
        });
    }

    protected processToolsAll(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    execute(body: ToolRequest | undefined): Promise<ToolResult> {
        let url_ = this.baseUrl + "/api/chat/tools/execute";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExecute(_response);
        });
    }

    protected processExecute(response: Response): Promise<ToolResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ToolResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ToolResult>(null as any);
    }

    /**
     * @return Success
     */
    classification(noteId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Classification/{noteId}";
        if (noteId === undefined || noteId === null)
            throw new globalThis.Error("The parameter 'noteId' must be defined.");
        url_ = url_.replace("{noteId}", encodeURIComponent("" + noteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processClassification(_response);
        });
    }

    protected processClassification(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    bulk(body: BulkClassificationRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Classification/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBulk(_response);
        });
    }

    protected processBulk(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    healthCheck(): Promise<void> {
        let url_ = this.baseUrl + "/health";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHealthCheck(_response);
        });
    }

    protected processHealthCheck(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    achievements(): Promise<void> {
        let url_ = this.baseUrl + "/api/Gamification/achievements";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAchievements(_response);
        });
    }

    protected processAchievements(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    myAchievements(): Promise<void> {
        let url_ = this.baseUrl + "/api/Gamification/my-achievements";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMyAchievements(_response);
        });
    }

    protected processMyAchievements(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    stats2(): Promise<void> {
        let url_ = this.baseUrl + "/api/Gamification/stats";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStats2(_response);
        });
    }

    protected processStats2(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    progress(): Promise<void> {
        let url_ = this.baseUrl + "/api/Gamification/progress";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProgress(_response);
        });
    }

    protected processProgress(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    checkAchievements(): Promise<void> {
        let url_ = this.baseUrl + "/api/Gamification/check-achievements";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCheckAchievements(_response);
        });
    }

    protected processCheckAchievements(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    seed(): Promise<void> {
        let url_ = this.baseUrl + "/api/Gamification/seed";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSeed(_response);
        });
    }

    protected processSeed(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    allAchievements(): Promise<void> {
        let url_ = this.baseUrl + "/api/Gamification/all-achievements";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAllAchievements(_response);
        });
    }

    protected processAllAchievements(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param focus (optional) 
     * @param depth (optional) 
     * @param entityTypes (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @return Success
     */
    graph(focus: string | undefined, depth: number | undefined, entityTypes: string[] | undefined, fromDate: Date | undefined, toDate: Date | undefined): Promise<GraphResponse> {
        let url_ = this.baseUrl + "/api/Graph?";
        if (focus === null)
            throw new globalThis.Error("The parameter 'focus' cannot be null.");
        else if (focus !== undefined)
            url_ += "focus=" + encodeURIComponent("" + focus) + "&";
        if (depth === null)
            throw new globalThis.Error("The parameter 'depth' cannot be null.");
        else if (depth !== undefined)
            url_ += "depth=" + encodeURIComponent("" + depth) + "&";
        if (entityTypes === null)
            throw new globalThis.Error("The parameter 'entityTypes' cannot be null.");
        else if (entityTypes !== undefined)
            entityTypes && entityTypes.forEach(item => { url_ += "entityTypes=" + encodeURIComponent("" + item) + "&"; });
        if (fromDate === null)
            throw new globalThis.Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new globalThis.Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGraph(_response);
        });
    }

    protected processGraph(response: Response): Promise<GraphResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GraphResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GraphResponse>(null as any);
    }

    /**
     * @param depth (optional) 
     * @return Success
     */
    connected(entityId: string, depth: number | undefined): Promise<GraphNode[]> {
        let url_ = this.baseUrl + "/api/Graph/entities/{entityId}/connected?";
        if (entityId === undefined || entityId === null)
            throw new globalThis.Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        if (depth === null)
            throw new globalThis.Error("The parameter 'depth' cannot be null.");
        else if (depth !== undefined)
            url_ += "depth=" + encodeURIComponent("" + depth) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processConnected(_response);
        });
    }

    protected processConnected(response: Response): Promise<GraphNode[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GraphNode.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GraphNode[]>(null as any);
    }

    /**
     * @return Success
     */
    suggestions(entityId: string): Promise<string[]> {
        let url_ = this.baseUrl + "/api/Graph/entities/{entityId}/suggestions";
        if (entityId === undefined || entityId === null)
            throw new globalThis.Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSuggestions(_response);
        });
    }

    protected processSuggestions(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }

    /**
     * @return Success
     */
    statistics(): Promise<{ [key: string]: number; }> {
        let url_ = this.baseUrl + "/api/Graph/statistics";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStatistics(_response);
        });
    }

    protected processStatistics(response: Response): Promise<{ [key: string]: number; }> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (result200 as any)![key] = resultData200[key] !== undefined ? resultData200[key] : null as any;
                }
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: number; }>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    extract(body: string | undefined): Promise<EntityExtraction[]> {
        let url_ = this.baseUrl + "/api/Graph/extract";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExtract(_response);
        });
    }

    protected processExtract(response: Response): Promise<EntityExtraction[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EntityExtraction.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EntityExtraction[]>(null as any);
    }

    /**
     * @return Success
     */
    coOccurrence(): Promise<void> {
        let url_ = this.baseUrl + "/api/Graph/discover/co-occurrence";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCoOccurrence(_response);
        });
    }

    protected processCoOccurrence(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    semantic(): Promise<void> {
        let url_ = this.baseUrl + "/api/Graph/discover/semantic";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSemantic(_response);
        });
    }

    protected processSemantic(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    temporal(): Promise<void> {
        let url_ = this.baseUrl + "/api/Graph/discover/temporal";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTemporal(_response);
        });
    }

    protected processTemporal(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    all(): Promise<void> {
        let url_ = this.baseUrl + "/api/Graph/discover/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAll(_response);
        });
    }

    protected processAll(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    insights(): Promise<GraphInsights> {
        let url_ = this.baseUrl + "/api/Graph/insights";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsights(_response);
        });
    }

    protected processInsights(response: Response): Promise<GraphInsights> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GraphInsights.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GraphInsights>(null as any);
    }

    /**
     * @return Success
     */
    health2(): Promise<void> {
        let url_ = this.baseUrl + "/api/Graph/health";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHealth2(_response);
        });
    }

    protected processHealth2(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param files (optional) 
     * @return Success
     */
    files(files: FileParameter[] | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Ingest/files";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (files === null || files === undefined)
            throw new globalThis.Error("The parameter 'files' cannot be null.");
        else
            files.forEach(item_ => content_.append("files", item_.data, item_.fileName ? item_.fileName : "files") );

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFiles(_response);
        });
    }

    protected processFiles(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    folder(body: FolderIngestRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Ingest/folder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFolder(_response);
        });
    }

    protected processFolder(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    notesGET(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Notes/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNotesGET(_response);
        });
    }

    protected processNotesGET(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    notesDELETE(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Notes/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNotesDELETE(_response);
        });
    }

    protected processNotesDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param limit (optional) 
     * @param offset (optional) 
     * @return Success
     */
    notesGET2(limit: number | undefined, offset: number | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Notes?";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new globalThis.Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNotesGET2(_response);
        });
    }

    protected processNotesGET2(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    query(body: RagQueryRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Rag/query";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processQuery(_response);
        });
    }

    protected processQuery(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    streamPOST(body: RagQueryRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Rag/stream";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStreamPOST(_response);
        });
    }

    protected processStreamPOST(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    preview(body: RedactionPreviewRequest | undefined): Promise<RedactionPreviewResponse> {
        let url_ = this.baseUrl + "/api/Redaction/preview";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPreview(_response);
        });
    }

    protected processPreview(response: Response): Promise<RedactionPreviewResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RedactionPreviewResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RedactionPreviewResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    verifyPin(body: VoicePinVerificationRequest | undefined): Promise<VoicePinVerificationResponse> {
        let url_ = this.baseUrl + "/api/Redaction/verify-pin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processVerifyPin(_response);
        });
    }

    protected processVerifyPin(response: Response): Promise<VoicePinVerificationResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VoicePinVerificationResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VoicePinVerificationResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setPin(body: VoicePinSetRequest | undefined): Promise<VoicePinSetResponse> {
        let url_ = this.baseUrl + "/api/Redaction/set-pin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetPin(_response);
        });
    }

    protected processSetPin(response: Response): Promise<VoicePinSetResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VoicePinSetResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VoicePinSetResponse>(null as any);
    }

    /**
     * @return Success
     */
    policy(): Promise<RedactionPolicyResponse> {
        let url_ = this.baseUrl + "/api/Redaction/policy";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPolicy(_response);
        });
    }

    protected processPolicy(response: Response): Promise<RedactionPolicyResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RedactionPolicyResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RedactionPolicyResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchPOST(body: SearchRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchPOST(_response);
        });
    }

    protected processSearchPOST(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param q (optional) 
     * @param k (optional) 
     * @param mode (optional) 
     * @param alpha (optional) 
     * @return Success
     */
    searchGET(q: string | undefined, k: number | undefined, mode: string | undefined, alpha: number | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Search?";
        if (q === null)
            throw new globalThis.Error("The parameter 'q' cannot be null.");
        else if (q !== undefined)
            url_ += "q=" + encodeURIComponent("" + q) + "&";
        if (k === null)
            throw new globalThis.Error("The parameter 'k' cannot be null.");
        else if (k !== undefined)
            url_ += "k=" + encodeURIComponent("" + k) + "&";
        if (mode === null)
            throw new globalThis.Error("The parameter 'mode' cannot be null.");
        else if (mode !== undefined)
            url_ += "mode=" + encodeURIComponent("" + mode) + "&";
        if (alpha === null)
            throw new globalThis.Error("The parameter 'alpha' cannot be null.");
        else if (alpha !== undefined)
            url_ += "alpha=" + encodeURIComponent("" + alpha) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchGET(_response);
        });
    }

    protected processSearchGET(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    advanced(body: AdvancedSearchRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Search/advanced";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAdvanced(_response);
        });
    }

    protected processAdvanced(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    seedData(): Promise<void> {
        let url_ = this.baseUrl + "/api/seed-data";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSeedData(_response);
        });
    }

    protected processSeedData(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    today(): Promise<DailyDigest> {
        let url_ = this.baseUrl + "/api/Suggestions/digest/today";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processToday(_response);
        });
    }

    protected processToday(response: Response): Promise<DailyDigest> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DailyDigest.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DailyDigest>(null as any);
    }

    /**
     * @return Success
     */
    digest(date: Date): Promise<DailyDigest> {
        let url_ = this.baseUrl + "/api/Suggestions/digest/{date}";
        if (date === undefined || date === null)
            throw new globalThis.Error("The parameter 'date' must be defined.");
        url_ = url_.replace("{date}", encodeURIComponent(date ? "" + date.toISOString() : "null"));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDigest(_response);
        });
    }

    protected processDigest(response: Response): Promise<DailyDigest> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DailyDigest.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DailyDigest>(null as any);
    }

    /**
     * @param limit (optional) 
     * @return Success
     */
    proactive(limit: number | undefined): Promise<ProactiveSuggestion[]> {
        let url_ = this.baseUrl + "/api/Suggestions/proactive?";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProactive(_response);
        });
    }

    protected processProactive(response: Response): Promise<ProactiveSuggestion[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProactiveSuggestion.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProactiveSuggestion[]>(null as any);
    }

    /**
     * @param days (optional) 
     * @param limit (optional) 
     * @return Success
     */
    trending(days: number | undefined, limit: number | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/Suggestions/trending?";
        if (days === null)
            throw new globalThis.Error("The parameter 'days' cannot be null.");
        else if (days !== undefined)
            url_ += "days=" + encodeURIComponent("" + days) + "&";
        if (limit === null)
            throw new globalThis.Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTrending(_response);
        });
    }

    protected processTrending(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }

    /**
     * @param entityType (optional) 
     * @return Success
     */
    insightsAll(entityType: string | undefined): Promise<EntityInsight[]> {
        let url_ = this.baseUrl + "/api/Suggestions/entities/insights?";
        if (entityType === null)
            throw new globalThis.Error("The parameter 'entityType' cannot be null.");
        else if (entityType !== undefined)
            url_ += "entityType=" + encodeURIComponent("" + entityType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsightsAll(_response);
        });
    }

    protected processInsightsAll(response: Response): Promise<EntityInsight[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EntityInsight.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EntityInsight[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    bulk2(body: BulkTagRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Tags/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBulk2(_response);
        });
    }

    protected processBulk2(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    tags(): Promise<void> {
        let url_ = this.baseUrl + "/api/Tags";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTags(_response);
        });
    }

    protected processTags(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    tags2(noteId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Tags/{noteId}";
        if (noteId === undefined || noteId === null)
            throw new globalThis.Error("The parameter 'noteId' must be defined.");
        url_ = url_.replace("{noteId}", encodeURIComponent("" + noteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTags2(_response);
        });
    }

    protected processTags2(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    profileGET(): Promise<UserProfile> {
        let url_ = this.baseUrl + "/api/User/profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProfileGET(_response);
        });
    }

    protected processProfileGET(response: Response): Promise<UserProfile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserProfile.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserProfile>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    profilePOST(body: CreateUserProfileRequest | undefined): Promise<UserProfile> {
        let url_ = this.baseUrl + "/api/User/profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProfilePOST(_response);
        });
    }

    protected processProfilePOST(response: Response): Promise<UserProfile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserProfile.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserProfile>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    profilePUT(body: UpdateUserProfileRequest | undefined): Promise<UserProfile> {
        let url_ = this.baseUrl + "/api/User/profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProfilePUT(_response);
        });
    }

    protected processProfilePUT(response: Response): Promise<UserProfile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserProfile.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserProfile>(null as any);
    }

    /**
     * @return Success
     */
    profileDELETE(): Promise<void> {
        let url_ = this.baseUrl + "/api/User/profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProfileDELETE(_response);
        });
    }

    protected processProfileDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    settingsGET(): Promise<UserSettingsDto> {
        let url_ = this.baseUrl + "/api/User/settings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSettingsGET(_response);
        });
    }

    protected processSettingsGET(response: Response): Promise<UserSettingsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserSettingsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSettingsDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    settingsPUT(body: UserSettingsDto | undefined): Promise<UserSettingsDto> {
        let url_ = this.baseUrl + "/api/User/settings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSettingsPUT(_response);
        });
    }

    protected processSettingsPUT(response: Response): Promise<UserSettingsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserSettingsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSettingsDto>(null as any);
    }

    /**
     * @return Success
     */
    export(): Promise<AccountExportResponse> {
        let url_ = this.baseUrl + "/api/User/account/export";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExport(_response);
        });
    }

    protected processExport(response: Response): Promise<AccountExportResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccountExportResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AccountExportResponse>(null as any);
    }

    /**
     * @return No Content
     */
    data(): Promise<void> {
        let url_ = this.baseUrl + "/api/User/account/data";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processData(_response);
        });
    }

    protected processData(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return No Content
     */
    account(): Promise<void> {
        let url_ = this.baseUrl + "/api/User/account";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAccount(_response);
        });
    }

    protected processAccount(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    stt(): Promise<void> {
        let url_ = this.baseUrl + "/api/Voice/stt";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStt(_response);
        });
    }

    protected processStt(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    tts(body: VoiceTtsRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Voice/tts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTts(_response);
        });
    }

    protected processTts(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param text (optional) 
     * @param format (optional) 
     * @return Success
     */
    streamGET(text: string | undefined, format: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Voice/tts/stream?";
        if (text === null)
            throw new globalThis.Error("The parameter 'text' cannot be null.");
        else if (text !== undefined)
            url_ += "text=" + encodeURIComponent("" + text) + "&";
        if (format === null)
            throw new globalThis.Error("The parameter 'format' cannot be null.");
        else if (format !== undefined)
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStreamGET(_response);
        });
    }

    protected processStreamGET(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class AccountExportResponse implements IAccountExportResponse {
    profile?: UserProfile;
    notes?: Note[] | undefined;
    chunks?: NoteChunk[] | undefined;
    classifications?: Classification[] | undefined;
    noteTags?: NoteTag[] | undefined;
    achievements?: UserAchievementExport[] | undefined;

    constructor(data?: IAccountExportResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.profile = _data["profile"] ? UserProfile.fromJS(_data["profile"]) : undefined as any;
            if (Array.isArray(_data["notes"])) {
                this.notes = [] as any;
                for (let item of _data["notes"])
                    this.notes!.push(Note.fromJS(item));
            }
            if (Array.isArray(_data["chunks"])) {
                this.chunks = [] as any;
                for (let item of _data["chunks"])
                    this.chunks!.push(NoteChunk.fromJS(item));
            }
            if (Array.isArray(_data["classifications"])) {
                this.classifications = [] as any;
                for (let item of _data["classifications"])
                    this.classifications!.push(Classification.fromJS(item));
            }
            if (Array.isArray(_data["noteTags"])) {
                this.noteTags = [] as any;
                for (let item of _data["noteTags"])
                    this.noteTags!.push(NoteTag.fromJS(item));
            }
            if (Array.isArray(_data["achievements"])) {
                this.achievements = [] as any;
                for (let item of _data["achievements"])
                    this.achievements!.push(UserAchievementExport.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AccountExportResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AccountExportResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profile"] = this.profile ? this.profile.toJSON() : undefined as any;
        if (Array.isArray(this.notes)) {
            data["notes"] = [];
            for (let item of this.notes)
                data["notes"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.chunks)) {
            data["chunks"] = [];
            for (let item of this.chunks)
                data["chunks"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.classifications)) {
            data["classifications"] = [];
            for (let item of this.classifications)
                data["classifications"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.noteTags)) {
            data["noteTags"] = [];
            for (let item of this.noteTags)
                data["noteTags"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.achievements)) {
            data["achievements"] = [];
            for (let item of this.achievements)
                data["achievements"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IAccountExportResponse {
    profile?: UserProfile;
    notes?: Note[] | undefined;
    chunks?: NoteChunk[] | undefined;
    classifications?: Classification[] | undefined;
    noteTags?: NoteTag[] | undefined;
    achievements?: UserAchievementExport[] | undefined;
}

export class Achievement implements IAchievement {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    icon?: string | undefined;
    category?: string | undefined;
    points?: number;
    isHidden?: boolean;
    sortOrder?: number;
    criteria?: string | undefined;
    createdAt?: Date;
    userAchievements?: UserAchievement[] | undefined;

    constructor(data?: IAchievement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.icon = _data["icon"];
            this.category = _data["category"];
            this.points = _data["points"];
            this.isHidden = _data["isHidden"];
            this.sortOrder = _data["sortOrder"];
            this.criteria = _data["criteria"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            if (Array.isArray(_data["userAchievements"])) {
                this.userAchievements = [] as any;
                for (let item of _data["userAchievements"])
                    this.userAchievements!.push(UserAchievement.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Achievement {
        data = typeof data === 'object' ? data : {};
        let result = new Achievement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["icon"] = this.icon;
        data["category"] = this.category;
        data["points"] = this.points;
        data["isHidden"] = this.isHidden;
        data["sortOrder"] = this.sortOrder;
        data["criteria"] = this.criteria;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        if (Array.isArray(this.userAchievements)) {
            data["userAchievements"] = [];
            for (let item of this.userAchievements)
                data["userAchievements"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IAchievement {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    icon?: string | undefined;
    category?: string | undefined;
    points?: number;
    isHidden?: boolean;
    sortOrder?: number;
    criteria?: string | undefined;
    createdAt?: Date;
    userAchievements?: UserAchievement[] | undefined;
}

export class ActivitySummary implements IActivitySummary {
    notesCreated?: number;
    topCategories?: CategoryCount[] | undefined;
    trendingEntities?: EntityTrend[] | undefined;

    constructor(data?: IActivitySummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.notesCreated = _data["notesCreated"];
            if (Array.isArray(_data["topCategories"])) {
                this.topCategories = [] as any;
                for (let item of _data["topCategories"])
                    this.topCategories!.push(CategoryCount.fromJS(item));
            }
            if (Array.isArray(_data["trendingEntities"])) {
                this.trendingEntities = [] as any;
                for (let item of _data["trendingEntities"])
                    this.trendingEntities!.push(EntityTrend.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ActivitySummary {
        data = typeof data === 'object' ? data : {};
        let result = new ActivitySummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["notesCreated"] = this.notesCreated;
        if (Array.isArray(this.topCategories)) {
            data["topCategories"] = [];
            for (let item of this.topCategories)
                data["topCategories"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.trendingEntities)) {
            data["trendingEntities"] = [];
            for (let item of this.trendingEntities)
                data["trendingEntities"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IActivitySummary {
    notesCreated?: number;
    topCategories?: CategoryCount[] | undefined;
    trendingEntities?: EntityTrend[] | undefined;
}

export class AdvancedSearchRequest implements IAdvancedSearchRequest {
    q?: string | undefined;
    k?: number;
    mode?: string | undefined;
    alpha?: number;
    useReranking?: boolean;
    sensitivityLevels?: number[] | undefined;
    tags?: string[] | undefined;
    piiTypes?: string[] | undefined;
    secretTypes?: string[] | undefined;
    excludePii?: boolean;
    excludeSecrets?: boolean;
    dateFrom?: Date | undefined;
    dateTo?: Date | undefined;
    fileTypes?: string[] | undefined;
    source?: string | undefined;

    constructor(data?: IAdvancedSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.q = _data["q"];
            this.k = _data["k"];
            this.mode = _data["mode"];
            this.alpha = _data["alpha"];
            this.useReranking = _data["useReranking"];
            if (Array.isArray(_data["sensitivityLevels"])) {
                this.sensitivityLevels = [] as any;
                for (let item of _data["sensitivityLevels"])
                    this.sensitivityLevels!.push(item);
            }
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            if (Array.isArray(_data["piiTypes"])) {
                this.piiTypes = [] as any;
                for (let item of _data["piiTypes"])
                    this.piiTypes!.push(item);
            }
            if (Array.isArray(_data["secretTypes"])) {
                this.secretTypes = [] as any;
                for (let item of _data["secretTypes"])
                    this.secretTypes!.push(item);
            }
            this.excludePii = _data["excludePii"];
            this.excludeSecrets = _data["excludeSecrets"];
            this.dateFrom = _data["dateFrom"] ? new Date(_data["dateFrom"].toString()) : undefined as any;
            this.dateTo = _data["dateTo"] ? new Date(_data["dateTo"].toString()) : undefined as any;
            if (Array.isArray(_data["fileTypes"])) {
                this.fileTypes = [] as any;
                for (let item of _data["fileTypes"])
                    this.fileTypes!.push(item);
            }
            this.source = _data["source"];
        }
    }

    static fromJS(data: any): AdvancedSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AdvancedSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["q"] = this.q;
        data["k"] = this.k;
        data["mode"] = this.mode;
        data["alpha"] = this.alpha;
        data["useReranking"] = this.useReranking;
        if (Array.isArray(this.sensitivityLevels)) {
            data["sensitivityLevels"] = [];
            for (let item of this.sensitivityLevels)
                data["sensitivityLevels"].push(item);
        }
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        if (Array.isArray(this.piiTypes)) {
            data["piiTypes"] = [];
            for (let item of this.piiTypes)
                data["piiTypes"].push(item);
        }
        if (Array.isArray(this.secretTypes)) {
            data["secretTypes"] = [];
            for (let item of this.secretTypes)
                data["secretTypes"].push(item);
        }
        data["excludePii"] = this.excludePii;
        data["excludeSecrets"] = this.excludeSecrets;
        data["dateFrom"] = this.dateFrom ? this.dateFrom.toISOString() : undefined as any;
        data["dateTo"] = this.dateTo ? this.dateTo.toISOString() : undefined as any;
        if (Array.isArray(this.fileTypes)) {
            data["fileTypes"] = [];
            for (let item of this.fileTypes)
                data["fileTypes"].push(item);
        }
        data["source"] = this.source;
        return data;
    }
}

export interface IAdvancedSearchRequest {
    q?: string | undefined;
    k?: number;
    mode?: string | undefined;
    alpha?: number;
    useReranking?: boolean;
    sensitivityLevels?: number[] | undefined;
    tags?: string[] | undefined;
    piiTypes?: string[] | undefined;
    secretTypes?: string[] | undefined;
    excludePii?: boolean;
    excludeSecrets?: boolean;
    dateFrom?: Date | undefined;
    dateTo?: Date | undefined;
    fileTypes?: string[] | undefined;
    source?: string | undefined;
}

export class BulkClassificationRequest implements IBulkClassificationRequest {
    noteIds?: string[] | undefined;

    constructor(data?: IBulkClassificationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["noteIds"])) {
                this.noteIds = [] as any;
                for (let item of _data["noteIds"])
                    this.noteIds!.push(item);
            }
        }
    }

    static fromJS(data: any): BulkClassificationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BulkClassificationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.noteIds)) {
            data["noteIds"] = [];
            for (let item of this.noteIds)
                data["noteIds"].push(item);
        }
        return data;
    }
}

export interface IBulkClassificationRequest {
    noteIds?: string[] | undefined;
}

export class BulkTagRequest implements IBulkTagRequest {
    noteIds?: string[] | undefined;
    add?: string[] | undefined;
    remove?: string[] | undefined;

    constructor(data?: IBulkTagRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["noteIds"])) {
                this.noteIds = [] as any;
                for (let item of _data["noteIds"])
                    this.noteIds!.push(item);
            }
            if (Array.isArray(_data["add"])) {
                this.add = [] as any;
                for (let item of _data["add"])
                    this.add!.push(item);
            }
            if (Array.isArray(_data["remove"])) {
                this.remove = [] as any;
                for (let item of _data["remove"])
                    this.remove!.push(item);
            }
        }
    }

    static fromJS(data: any): BulkTagRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BulkTagRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.noteIds)) {
            data["noteIds"] = [];
            for (let item of this.noteIds)
                data["noteIds"].push(item);
        }
        if (Array.isArray(this.add)) {
            data["add"] = [];
            for (let item of this.add)
                data["add"].push(item);
        }
        if (Array.isArray(this.remove)) {
            data["remove"] = [];
            for (let item of this.remove)
                data["remove"].push(item);
        }
        return data;
    }
}

export interface IBulkTagRequest {
    noteIds?: string[] | undefined;
    add?: string[] | undefined;
    remove?: string[] | undefined;
}

export class CategoryCount implements ICategoryCount {
    category?: string | undefined;
    count?: number;

    constructor(data?: ICategoryCount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.category = _data["category"];
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): CategoryCount {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryCount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        data["count"] = this.count;
        return data;
    }
}

export interface ICategoryCount {
    category?: string | undefined;
    count?: number;
}

export class ChatToolsRequest implements IChatToolsRequest {
    query?: string | undefined;
    availableTools?: string[] | undefined;
    context?: { [key: string]: any; } | undefined;

    constructor(data?: IChatToolsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.query = _data["query"];
            if (Array.isArray(_data["availableTools"])) {
                this.availableTools = [] as any;
                for (let item of _data["availableTools"])
                    this.availableTools!.push(item);
            }
            if (_data["context"]) {
                this.context = {} as any;
                for (let key in _data["context"]) {
                    if (_data["context"].hasOwnProperty(key))
                        (this.context as any)![key] = _data["context"][key];
                }
            }
        }
    }

    static fromJS(data: any): ChatToolsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ChatToolsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["query"] = this.query;
        if (Array.isArray(this.availableTools)) {
            data["availableTools"] = [];
            for (let item of this.availableTools)
                data["availableTools"].push(item);
        }
        if (this.context) {
            data["context"] = {};
            for (let key in this.context) {
                if (this.context.hasOwnProperty(key))
                    (data["context"] as any)[key] = (this.context as any)[key];
            }
        }
        return data;
    }
}

export interface IChatToolsRequest {
    query?: string | undefined;
    availableTools?: string[] | undefined;
    context?: { [key: string]: any; } | undefined;
}

export class ChatToolsResponse implements IChatToolsResponse {
    response?: string | undefined;
    suggestedTools?: ToolRequest[] | undefined;
    requiresConfirmation?: boolean;

    constructor(data?: IChatToolsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.response = _data["response"];
            if (Array.isArray(_data["suggestedTools"])) {
                this.suggestedTools = [] as any;
                for (let item of _data["suggestedTools"])
                    this.suggestedTools!.push(ToolRequest.fromJS(item));
            }
            this.requiresConfirmation = _data["requiresConfirmation"];
        }
    }

    static fromJS(data: any): ChatToolsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ChatToolsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["response"] = this.response;
        if (Array.isArray(this.suggestedTools)) {
            data["suggestedTools"] = [];
            for (let item of this.suggestedTools)
                data["suggestedTools"].push(item ? item.toJSON() : undefined as any);
        }
        data["requiresConfirmation"] = this.requiresConfirmation;
        return data;
    }
}

export interface IChatToolsResponse {
    response?: string | undefined;
    suggestedTools?: ToolRequest[] | undefined;
    requiresConfirmation?: boolean;
}

export class Classification implements IClassification {
    id?: string | undefined;
    noteId?: string | undefined;
    label?: string | undefined;
    score?: number;
    model?: string | undefined;
    createdAt?: Date;
    note?: Note;

    constructor(data?: IClassification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.noteId = _data["noteId"];
            this.label = _data["label"];
            this.score = _data["score"];
            this.model = _data["model"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.note = _data["note"] ? Note.fromJS(_data["note"]) : undefined as any;
        }
    }

    static fromJS(data: any): Classification {
        data = typeof data === 'object' ? data : {};
        let result = new Classification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["noteId"] = this.noteId;
        data["label"] = this.label;
        data["score"] = this.score;
        data["model"] = this.model;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["note"] = this.note ? this.note.toJSON() : undefined as any;
        return data;
    }
}

export interface IClassification {
    id?: string | undefined;
    noteId?: string | undefined;
    label?: string | undefined;
    score?: number;
    model?: string | undefined;
    createdAt?: Date;
    note?: Note;
}

export class CreateUserProfileRequest implements ICreateUserProfileRequest {
    email?: string | undefined;
    name?: string | undefined;
    subjectId?: string | undefined;
    bio?: string | undefined;
    avatar?: string | undefined;

    constructor(data?: ICreateUserProfileRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.name = _data["name"];
            this.subjectId = _data["subjectId"];
            this.bio = _data["bio"];
            this.avatar = _data["avatar"];
        }
    }

    static fromJS(data: any): CreateUserProfileRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserProfileRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["name"] = this.name;
        data["subjectId"] = this.subjectId;
        data["bio"] = this.bio;
        data["avatar"] = this.avatar;
        return data;
    }
}

export interface ICreateUserProfileRequest {
    email?: string | undefined;
    name?: string | undefined;
    subjectId?: string | undefined;
    bio?: string | undefined;
    avatar?: string | undefined;
}

export class DailyDigest implements IDailyDigest {
    date?: Date;
    summary?: string | undefined;
    recentActivity?: ActivitySummary;
    keyInsights?: string[] | undefined;
    proactiveSuggestions?: ProactiveSuggestion[] | undefined;
    entityClusters?: EntityCluster[] | undefined;
    generatedAt?: Date;

    constructor(data?: IDailyDigest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : undefined as any;
            this.summary = _data["summary"];
            this.recentActivity = _data["recentActivity"] ? ActivitySummary.fromJS(_data["recentActivity"]) : undefined as any;
            if (Array.isArray(_data["keyInsights"])) {
                this.keyInsights = [] as any;
                for (let item of _data["keyInsights"])
                    this.keyInsights!.push(item);
            }
            if (Array.isArray(_data["proactiveSuggestions"])) {
                this.proactiveSuggestions = [] as any;
                for (let item of _data["proactiveSuggestions"])
                    this.proactiveSuggestions!.push(ProactiveSuggestion.fromJS(item));
            }
            if (Array.isArray(_data["entityClusters"])) {
                this.entityClusters = [] as any;
                for (let item of _data["entityClusters"])
                    this.entityClusters!.push(EntityCluster.fromJS(item));
            }
            this.generatedAt = _data["generatedAt"] ? new Date(_data["generatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): DailyDigest {
        data = typeof data === 'object' ? data : {};
        let result = new DailyDigest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : undefined as any;
        data["summary"] = this.summary;
        data["recentActivity"] = this.recentActivity ? this.recentActivity.toJSON() : undefined as any;
        if (Array.isArray(this.keyInsights)) {
            data["keyInsights"] = [];
            for (let item of this.keyInsights)
                data["keyInsights"].push(item);
        }
        if (Array.isArray(this.proactiveSuggestions)) {
            data["proactiveSuggestions"] = [];
            for (let item of this.proactiveSuggestions)
                data["proactiveSuggestions"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.entityClusters)) {
            data["entityClusters"] = [];
            for (let item of this.entityClusters)
                data["entityClusters"].push(item ? item.toJSON() : undefined as any);
        }
        data["generatedAt"] = this.generatedAt ? this.generatedAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IDailyDigest {
    date?: Date;
    summary?: string | undefined;
    recentActivity?: ActivitySummary;
    keyInsights?: string[] | undefined;
    proactiveSuggestions?: ProactiveSuggestion[] | undefined;
    entityClusters?: EntityCluster[] | undefined;
    generatedAt?: Date;
}

export class Edge implements IEdge {
    id?: string | undefined;
    fromEntityId?: string | undefined;
    toEntityId?: string | undefined;
    relationType?: string | undefined;
    confidence?: number;
    source?: string | undefined;
    createdAt?: Date;
    fromEntity?: Entity;
    toEntity?: Entity;

    constructor(data?: IEdge) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fromEntityId = _data["fromEntityId"];
            this.toEntityId = _data["toEntityId"];
            this.relationType = _data["relationType"];
            this.confidence = _data["confidence"];
            this.source = _data["source"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.fromEntity = _data["fromEntity"] ? Entity.fromJS(_data["fromEntity"]) : undefined as any;
            this.toEntity = _data["toEntity"] ? Entity.fromJS(_data["toEntity"]) : undefined as any;
        }
    }

    static fromJS(data: any): Edge {
        data = typeof data === 'object' ? data : {};
        let result = new Edge();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fromEntityId"] = this.fromEntityId;
        data["toEntityId"] = this.toEntityId;
        data["relationType"] = this.relationType;
        data["confidence"] = this.confidence;
        data["source"] = this.source;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["fromEntity"] = this.fromEntity ? this.fromEntity.toJSON() : undefined as any;
        data["toEntity"] = this.toEntity ? this.toEntity.toJSON() : undefined as any;
        return data;
    }
}

export interface IEdge {
    id?: string | undefined;
    fromEntityId?: string | undefined;
    toEntityId?: string | undefined;
    relationType?: string | undefined;
    confidence?: number;
    source?: string | undefined;
    createdAt?: Date;
    fromEntity?: Entity;
    toEntity?: Entity;
}

export class EmbedReindexRequest implements IEmbedReindexRequest {
    scope?: string | undefined;
    noteId?: string | undefined;
    since?: Date | undefined;

    constructor(data?: IEmbedReindexRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.scope = _data["scope"];
            this.noteId = _data["noteId"];
            this.since = _data["since"] ? new Date(_data["since"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): EmbedReindexRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EmbedReindexRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scope"] = this.scope;
        data["noteId"] = this.noteId;
        data["since"] = this.since ? this.since.toISOString() : undefined as any;
        return data;
    }
}

export interface IEmbedReindexRequest {
    scope?: string | undefined;
    noteId?: string | undefined;
    since?: Date | undefined;
}

export class EmbedReindexResponse implements IEmbedReindexResponse {
    success?: boolean;
    processedCount?: number;
    errorCount?: number;
    errors?: string[] | undefined;
    durationMs?: number;
    completedAt?: Date;

    constructor(data?: IEmbedReindexResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.processedCount = _data["processedCount"];
            this.errorCount = _data["errorCount"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.durationMs = _data["durationMs"];
            this.completedAt = _data["completedAt"] ? new Date(_data["completedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): EmbedReindexResponse {
        data = typeof data === 'object' ? data : {};
        let result = new EmbedReindexResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["processedCount"] = this.processedCount;
        data["errorCount"] = this.errorCount;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["durationMs"] = this.durationMs;
        data["completedAt"] = this.completedAt ? this.completedAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IEmbedReindexResponse {
    success?: boolean;
    processedCount?: number;
    errorCount?: number;
    errors?: string[] | undefined;
    durationMs?: number;
    completedAt?: Date;
}

export class EmbedStatsResponse implements IEmbedStatsResponse {
    totalNotes?: number;
    totalChunks?: number;
    totalEmbeddings?: number;
    chunksWithoutEmbeddings?: number;
    coveragePercentage?: number;
    newestEmbeddingAt?: Date | undefined;
    oldestEmbeddingAt?: Date | undefined;
    providerBreakdown?: { [key: string]: number; } | undefined;
    modelBreakdown?: { [key: string]: number; } | undefined;

    constructor(data?: IEmbedStatsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalNotes = _data["totalNotes"];
            this.totalChunks = _data["totalChunks"];
            this.totalEmbeddings = _data["totalEmbeddings"];
            this.chunksWithoutEmbeddings = _data["chunksWithoutEmbeddings"];
            this.coveragePercentage = _data["coveragePercentage"];
            this.newestEmbeddingAt = _data["newestEmbeddingAt"] ? new Date(_data["newestEmbeddingAt"].toString()) : undefined as any;
            this.oldestEmbeddingAt = _data["oldestEmbeddingAt"] ? new Date(_data["oldestEmbeddingAt"].toString()) : undefined as any;
            if (_data["providerBreakdown"]) {
                this.providerBreakdown = {} as any;
                for (let key in _data["providerBreakdown"]) {
                    if (_data["providerBreakdown"].hasOwnProperty(key))
                        (this.providerBreakdown as any)![key] = _data["providerBreakdown"][key];
                }
            }
            if (_data["modelBreakdown"]) {
                this.modelBreakdown = {} as any;
                for (let key in _data["modelBreakdown"]) {
                    if (_data["modelBreakdown"].hasOwnProperty(key))
                        (this.modelBreakdown as any)![key] = _data["modelBreakdown"][key];
                }
            }
        }
    }

    static fromJS(data: any): EmbedStatsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new EmbedStatsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalNotes"] = this.totalNotes;
        data["totalChunks"] = this.totalChunks;
        data["totalEmbeddings"] = this.totalEmbeddings;
        data["chunksWithoutEmbeddings"] = this.chunksWithoutEmbeddings;
        data["coveragePercentage"] = this.coveragePercentage;
        data["newestEmbeddingAt"] = this.newestEmbeddingAt ? this.newestEmbeddingAt.toISOString() : undefined as any;
        data["oldestEmbeddingAt"] = this.oldestEmbeddingAt ? this.oldestEmbeddingAt.toISOString() : undefined as any;
        if (this.providerBreakdown) {
            data["providerBreakdown"] = {};
            for (let key in this.providerBreakdown) {
                if (this.providerBreakdown.hasOwnProperty(key))
                    (data["providerBreakdown"] as any)[key] = (this.providerBreakdown as any)[key];
            }
        }
        if (this.modelBreakdown) {
            data["modelBreakdown"] = {};
            for (let key in this.modelBreakdown) {
                if (this.modelBreakdown.hasOwnProperty(key))
                    (data["modelBreakdown"] as any)[key] = (this.modelBreakdown as any)[key];
            }
        }
        return data;
    }
}

export interface IEmbedStatsResponse {
    totalNotes?: number;
    totalChunks?: number;
    totalEmbeddings?: number;
    chunksWithoutEmbeddings?: number;
    coveragePercentage?: number;
    newestEmbeddingAt?: Date | undefined;
    oldestEmbeddingAt?: Date | undefined;
    providerBreakdown?: { [key: string]: number; } | undefined;
    modelBreakdown?: { [key: string]: number; } | undefined;
}

export class Embedding implements IEmbedding {
    id?: string | undefined;
    chunkId?: string | undefined;
    provider?: string | undefined;
    model?: string | undefined;
    dim?: number;
    vectorRef?: string | undefined;
    createdAt?: Date;
    chunk?: NoteChunk;

    constructor(data?: IEmbedding) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.chunkId = _data["chunkId"];
            this.provider = _data["provider"];
            this.model = _data["model"];
            this.dim = _data["dim"];
            this.vectorRef = _data["vectorRef"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.chunk = _data["chunk"] ? NoteChunk.fromJS(_data["chunk"]) : undefined as any;
        }
    }

    static fromJS(data: any): Embedding {
        data = typeof data === 'object' ? data : {};
        let result = new Embedding();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["chunkId"] = this.chunkId;
        data["provider"] = this.provider;
        data["model"] = this.model;
        data["dim"] = this.dim;
        data["vectorRef"] = this.vectorRef;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["chunk"] = this.chunk ? this.chunk.toJSON() : undefined as any;
        return data;
    }
}

export interface IEmbedding {
    id?: string | undefined;
    chunkId?: string | undefined;
    provider?: string | undefined;
    model?: string | undefined;
    dim?: number;
    vectorRef?: string | undefined;
    createdAt?: Date;
    chunk?: NoteChunk;
}

export class Entity implements IEntity {
    id?: string | undefined;
    type?: string | undefined;
    value?: string | undefined;
    canonicalValue?: string | undefined;
    canonicalEntityId?: string | undefined;
    confidenceScore?: number;
    mentionCount?: number;
    createdAt?: Date;
    lastSeenAt?: Date;
    canonicalEntity?: Entity;
    outgoingEdges?: Edge[] | undefined;
    incomingEdges?: Edge[] | undefined;

    constructor(data?: IEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.value = _data["value"];
            this.canonicalValue = _data["canonicalValue"];
            this.canonicalEntityId = _data["canonicalEntityId"];
            this.confidenceScore = _data["confidenceScore"];
            this.mentionCount = _data["mentionCount"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.lastSeenAt = _data["lastSeenAt"] ? new Date(_data["lastSeenAt"].toString()) : undefined as any;
            this.canonicalEntity = _data["canonicalEntity"] ? Entity.fromJS(_data["canonicalEntity"]) : undefined as any;
            if (Array.isArray(_data["outgoingEdges"])) {
                this.outgoingEdges = [] as any;
                for (let item of _data["outgoingEdges"])
                    this.outgoingEdges!.push(Edge.fromJS(item));
            }
            if (Array.isArray(_data["incomingEdges"])) {
                this.incomingEdges = [] as any;
                for (let item of _data["incomingEdges"])
                    this.incomingEdges!.push(Edge.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Entity {
        data = typeof data === 'object' ? data : {};
        let result = new Entity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["value"] = this.value;
        data["canonicalValue"] = this.canonicalValue;
        data["canonicalEntityId"] = this.canonicalEntityId;
        data["confidenceScore"] = this.confidenceScore;
        data["mentionCount"] = this.mentionCount;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["lastSeenAt"] = this.lastSeenAt ? this.lastSeenAt.toISOString() : undefined as any;
        data["canonicalEntity"] = this.canonicalEntity ? this.canonicalEntity.toJSON() : undefined as any;
        if (Array.isArray(this.outgoingEdges)) {
            data["outgoingEdges"] = [];
            for (let item of this.outgoingEdges)
                data["outgoingEdges"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.incomingEdges)) {
            data["incomingEdges"] = [];
            for (let item of this.incomingEdges)
                data["incomingEdges"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IEntity {
    id?: string | undefined;
    type?: string | undefined;
    value?: string | undefined;
    canonicalValue?: string | undefined;
    canonicalEntityId?: string | undefined;
    confidenceScore?: number;
    mentionCount?: number;
    createdAt?: Date;
    lastSeenAt?: Date;
    canonicalEntity?: Entity;
    outgoingEdges?: Edge[] | undefined;
    incomingEdges?: Edge[] | undefined;
}

export class EntityCluster implements IEntityCluster {
    name?: string | undefined;
    entityTypes?: string[] | undefined;
    strength?: number;
    description?: string | undefined;

    constructor(data?: IEntityCluster) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["entityTypes"])) {
                this.entityTypes = [] as any;
                for (let item of _data["entityTypes"])
                    this.entityTypes!.push(item);
            }
            this.strength = _data["strength"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): EntityCluster {
        data = typeof data === 'object' ? data : {};
        let result = new EntityCluster();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.entityTypes)) {
            data["entityTypes"] = [];
            for (let item of this.entityTypes)
                data["entityTypes"].push(item);
        }
        data["strength"] = this.strength;
        data["description"] = this.description;
        return data;
    }
}

export interface IEntityCluster {
    name?: string | undefined;
    entityTypes?: string[] | undefined;
    strength?: number;
    description?: string | undefined;
}

export class EntityExtraction implements IEntityExtraction {
    type?: string | undefined;
    value?: string | undefined;
    start?: number;
    end?: number;
    confidence?: number;

    constructor(data?: IEntityExtraction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.value = _data["value"];
            this.start = _data["start"];
            this.end = _data["end"];
            this.confidence = _data["confidence"];
        }
    }

    static fromJS(data: any): EntityExtraction {
        data = typeof data === 'object' ? data : {};
        let result = new EntityExtraction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["value"] = this.value;
        data["start"] = this.start;
        data["end"] = this.end;
        data["confidence"] = this.confidence;
        return data;
    }
}

export interface IEntityExtraction {
    type?: string | undefined;
    value?: string | undefined;
    start?: number;
    end?: number;
    confidence?: number;
}

export class EntityInsight implements IEntityInsight {
    entityType?: string | undefined;
    entityValue?: string | undefined;
    frequency?: number;
    lastSeen?: Date;
    confidence?: number;

    constructor(data?: IEntityInsight) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityType = _data["entityType"];
            this.entityValue = _data["entityValue"];
            this.frequency = _data["frequency"];
            this.lastSeen = _data["lastSeen"] ? new Date(_data["lastSeen"].toString()) : undefined as any;
            this.confidence = _data["confidence"];
        }
    }

    static fromJS(data: any): EntityInsight {
        data = typeof data === 'object' ? data : {};
        let result = new EntityInsight();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityType"] = this.entityType;
        data["entityValue"] = this.entityValue;
        data["frequency"] = this.frequency;
        data["lastSeen"] = this.lastSeen ? this.lastSeen.toISOString() : undefined as any;
        data["confidence"] = this.confidence;
        return data;
    }
}

export interface IEntityInsight {
    entityType?: string | undefined;
    entityValue?: string | undefined;
    frequency?: number;
    lastSeen?: Date;
    confidence?: number;
}

export class EntityTrend implements IEntityTrend {
    entityType?: string | undefined;
    count?: number;
    trendDirection?: string | undefined;

    constructor(data?: IEntityTrend) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityType = _data["entityType"];
            this.count = _data["count"];
            this.trendDirection = _data["trendDirection"];
        }
    }

    static fromJS(data: any): EntityTrend {
        data = typeof data === 'object' ? data : {};
        let result = new EntityTrend();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityType"] = this.entityType;
        data["count"] = this.count;
        data["trendDirection"] = this.trendDirection;
        return data;
    }
}

export interface IEntityTrend {
    entityType?: string | undefined;
    count?: number;
    trendDirection?: string | undefined;
}

export class FolderIngestRequest implements IFolderIngestRequest {
    path?: string | undefined;

    constructor(data?: IFolderIngestRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.path = _data["path"];
        }
    }

    static fromJS(data: any): FolderIngestRequest {
        data = typeof data === 'object' ? data : {};
        let result = new FolderIngestRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["path"] = this.path;
        return data;
    }
}

export interface IFolderIngestRequest {
    path?: string | undefined;
}

export class GraphEdge implements IGraphEdge {
    id?: string | undefined;
    fromId?: string | undefined;
    toId?: string | undefined;
    relationType?: string | undefined;
    confidence?: number;

    constructor(data?: IGraphEdge) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fromId = _data["fromId"];
            this.toId = _data["toId"];
            this.relationType = _data["relationType"];
            this.confidence = _data["confidence"];
        }
    }

    static fromJS(data: any): GraphEdge {
        data = typeof data === 'object' ? data : {};
        let result = new GraphEdge();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fromId"] = this.fromId;
        data["toId"] = this.toId;
        data["relationType"] = this.relationType;
        data["confidence"] = this.confidence;
        return data;
    }
}

export interface IGraphEdge {
    id?: string | undefined;
    fromId?: string | undefined;
    toId?: string | undefined;
    relationType?: string | undefined;
    confidence?: number;
}

export class GraphHub implements IGraphHub {
    entityId?: string | undefined;
    entityLabel?: string | undefined;
    entityType?: string | undefined;
    connectionCount?: number;

    constructor(data?: IGraphHub) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityId = _data["entityId"];
            this.entityLabel = _data["entityLabel"];
            this.entityType = _data["entityType"];
            this.connectionCount = _data["connectionCount"];
        }
    }

    static fromJS(data: any): GraphHub {
        data = typeof data === 'object' ? data : {};
        let result = new GraphHub();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityId"] = this.entityId;
        data["entityLabel"] = this.entityLabel;
        data["entityType"] = this.entityType;
        data["connectionCount"] = this.connectionCount;
        return data;
    }
}

export interface IGraphHub {
    entityId?: string | undefined;
    entityLabel?: string | undefined;
    entityType?: string | undefined;
    connectionCount?: number;
}

export class GraphInsights implements IGraphInsights {
    totalEntities?: number;
    totalRelationships?: number;
    connectedEntities?: number;
    isolatedEntities?: number;
    topHubs?: GraphHub[] | undefined;
    relationshipTypeDistribution?: { [key: string]: number; } | undefined;
    graphDensity?: number;
    generatedAt?: Date;

    constructor(data?: IGraphInsights) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalEntities = _data["totalEntities"];
            this.totalRelationships = _data["totalRelationships"];
            this.connectedEntities = _data["connectedEntities"];
            this.isolatedEntities = _data["isolatedEntities"];
            if (Array.isArray(_data["topHubs"])) {
                this.topHubs = [] as any;
                for (let item of _data["topHubs"])
                    this.topHubs!.push(GraphHub.fromJS(item));
            }
            if (_data["relationshipTypeDistribution"]) {
                this.relationshipTypeDistribution = {} as any;
                for (let key in _data["relationshipTypeDistribution"]) {
                    if (_data["relationshipTypeDistribution"].hasOwnProperty(key))
                        (this.relationshipTypeDistribution as any)![key] = _data["relationshipTypeDistribution"][key];
                }
            }
            this.graphDensity = _data["graphDensity"];
            this.generatedAt = _data["generatedAt"] ? new Date(_data["generatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): GraphInsights {
        data = typeof data === 'object' ? data : {};
        let result = new GraphInsights();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalEntities"] = this.totalEntities;
        data["totalRelationships"] = this.totalRelationships;
        data["connectedEntities"] = this.connectedEntities;
        data["isolatedEntities"] = this.isolatedEntities;
        if (Array.isArray(this.topHubs)) {
            data["topHubs"] = [];
            for (let item of this.topHubs)
                data["topHubs"].push(item ? item.toJSON() : undefined as any);
        }
        if (this.relationshipTypeDistribution) {
            data["relationshipTypeDistribution"] = {};
            for (let key in this.relationshipTypeDistribution) {
                if (this.relationshipTypeDistribution.hasOwnProperty(key))
                    (data["relationshipTypeDistribution"] as any)[key] = (this.relationshipTypeDistribution as any)[key];
            }
        }
        data["graphDensity"] = this.graphDensity;
        data["generatedAt"] = this.generatedAt ? this.generatedAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IGraphInsights {
    totalEntities?: number;
    totalRelationships?: number;
    connectedEntities?: number;
    isolatedEntities?: number;
    topHubs?: GraphHub[] | undefined;
    relationshipTypeDistribution?: { [key: string]: number; } | undefined;
    graphDensity?: number;
    generatedAt?: Date;
}

export class GraphNode implements IGraphNode {
    id?: string | undefined;
    type?: string | undefined;
    value?: string | undefined;
    connectionCount?: number;
    lastSeen?: Date;

    constructor(data?: IGraphNode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.value = _data["value"];
            this.connectionCount = _data["connectionCount"];
            this.lastSeen = _data["lastSeen"] ? new Date(_data["lastSeen"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): GraphNode {
        data = typeof data === 'object' ? data : {};
        let result = new GraphNode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["value"] = this.value;
        data["connectionCount"] = this.connectionCount;
        data["lastSeen"] = this.lastSeen ? this.lastSeen.toISOString() : undefined as any;
        return data;
    }
}

export interface IGraphNode {
    id?: string | undefined;
    type?: string | undefined;
    value?: string | undefined;
    connectionCount?: number;
    lastSeen?: Date;
}

export class GraphResponse implements IGraphResponse {
    nodes?: GraphNode[] | undefined;
    edges?: GraphEdge[] | undefined;
    totalNodes?: number;
    totalEdges?: number;

    constructor(data?: IGraphResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["nodes"])) {
                this.nodes = [] as any;
                for (let item of _data["nodes"])
                    this.nodes!.push(GraphNode.fromJS(item));
            }
            if (Array.isArray(_data["edges"])) {
                this.edges = [] as any;
                for (let item of _data["edges"])
                    this.edges!.push(GraphEdge.fromJS(item));
            }
            this.totalNodes = _data["totalNodes"];
            this.totalEdges = _data["totalEdges"];
        }
    }

    static fromJS(data: any): GraphResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GraphResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.nodes)) {
            data["nodes"] = [];
            for (let item of this.nodes)
                data["nodes"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.edges)) {
            data["edges"] = [];
            for (let item of this.edges)
                data["edges"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalNodes"] = this.totalNodes;
        data["totalEdges"] = this.totalEdges;
        return data;
    }
}

export interface IGraphResponse {
    nodes?: GraphNode[] | undefined;
    edges?: GraphEdge[] | undefined;
    totalNodes?: number;
    totalEdges?: number;
}

export class Note implements INote {
    id?: string | undefined;
    title?: string | undefined;
    userId?: string | undefined;
    content?: string | undefined;
    lang?: string | undefined;
    source?: string | undefined;
    isDeleted?: boolean;
    version?: number;
    sensitivityLevel?: number;
    piiFlags?: string | undefined;
    secretFlags?: string | undefined;
    summary?: string | undefined;
    originalPath?: string | undefined;
    filePath?: string | undefined;
    fileType?: string | undefined;
    sha256Hash?: string | undefined;
    fileSizeBytes?: number;
    createdAt?: Date;
    updatedAt?: Date;
    chunkCount?: number;
    tags?: string | undefined;
    chunks?: NoteChunk[] | undefined;
    noteTags?: NoteTag[] | undefined;
    classifications?: Classification[] | undefined;
    spans?: TextSpan[] | undefined;

    constructor(data?: INote) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.userId = _data["userId"];
            this.content = _data["content"];
            this.lang = _data["lang"];
            this.source = _data["source"];
            this.isDeleted = _data["isDeleted"];
            this.version = _data["version"];
            this.sensitivityLevel = _data["sensitivityLevel"];
            this.piiFlags = _data["piiFlags"];
            this.secretFlags = _data["secretFlags"];
            this.summary = _data["summary"];
            this.originalPath = _data["originalPath"];
            this.filePath = _data["filePath"];
            this.fileType = _data["fileType"];
            this.sha256Hash = _data["sha256Hash"];
            this.fileSizeBytes = _data["fileSizeBytes"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
            this.chunkCount = _data["chunkCount"];
            this.tags = _data["tags"];
            if (Array.isArray(_data["chunks"])) {
                this.chunks = [] as any;
                for (let item of _data["chunks"])
                    this.chunks!.push(NoteChunk.fromJS(item));
            }
            if (Array.isArray(_data["noteTags"])) {
                this.noteTags = [] as any;
                for (let item of _data["noteTags"])
                    this.noteTags!.push(NoteTag.fromJS(item));
            }
            if (Array.isArray(_data["classifications"])) {
                this.classifications = [] as any;
                for (let item of _data["classifications"])
                    this.classifications!.push(Classification.fromJS(item));
            }
            if (Array.isArray(_data["spans"])) {
                this.spans = [] as any;
                for (let item of _data["spans"])
                    this.spans!.push(TextSpan.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Note {
        data = typeof data === 'object' ? data : {};
        let result = new Note();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["userId"] = this.userId;
        data["content"] = this.content;
        data["lang"] = this.lang;
        data["source"] = this.source;
        data["isDeleted"] = this.isDeleted;
        data["version"] = this.version;
        data["sensitivityLevel"] = this.sensitivityLevel;
        data["piiFlags"] = this.piiFlags;
        data["secretFlags"] = this.secretFlags;
        data["summary"] = this.summary;
        data["originalPath"] = this.originalPath;
        data["filePath"] = this.filePath;
        data["fileType"] = this.fileType;
        data["sha256Hash"] = this.sha256Hash;
        data["fileSizeBytes"] = this.fileSizeBytes;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        data["chunkCount"] = this.chunkCount;
        data["tags"] = this.tags;
        if (Array.isArray(this.chunks)) {
            data["chunks"] = [];
            for (let item of this.chunks)
                data["chunks"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.noteTags)) {
            data["noteTags"] = [];
            for (let item of this.noteTags)
                data["noteTags"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.classifications)) {
            data["classifications"] = [];
            for (let item of this.classifications)
                data["classifications"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.spans)) {
            data["spans"] = [];
            for (let item of this.spans)
                data["spans"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface INote {
    id?: string | undefined;
    title?: string | undefined;
    userId?: string | undefined;
    content?: string | undefined;
    lang?: string | undefined;
    source?: string | undefined;
    isDeleted?: boolean;
    version?: number;
    sensitivityLevel?: number;
    piiFlags?: string | undefined;
    secretFlags?: string | undefined;
    summary?: string | undefined;
    originalPath?: string | undefined;
    filePath?: string | undefined;
    fileType?: string | undefined;
    sha256Hash?: string | undefined;
    fileSizeBytes?: number;
    createdAt?: Date;
    updatedAt?: Date;
    chunkCount?: number;
    tags?: string | undefined;
    chunks?: NoteChunk[] | undefined;
    noteTags?: NoteTag[] | undefined;
    classifications?: Classification[] | undefined;
    spans?: TextSpan[] | undefined;
}

export class NoteChunk implements INoteChunk {
    id?: string | undefined;
    noteId?: string | undefined;
    content?: string | undefined;
    chunkIndex?: number;
    tokenCount?: number;
    seq?: number;
    text?: string | undefined;
    sha256?: string | undefined;
    sensitivityLevel?: number;
    piiFlags?: string | undefined;
    secretFlags?: string | undefined;
    summary?: string | undefined;
    createdAt?: Date;
    note?: Note;
    embeddings?: Embedding[] | undefined;

    constructor(data?: INoteChunk) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.noteId = _data["noteId"];
            this.content = _data["content"];
            this.chunkIndex = _data["chunkIndex"];
            this.tokenCount = _data["tokenCount"];
            this.seq = _data["seq"];
            this.text = _data["text"];
            this.sha256 = _data["sha256"];
            this.sensitivityLevel = _data["sensitivityLevel"];
            this.piiFlags = _data["piiFlags"];
            this.secretFlags = _data["secretFlags"];
            this.summary = _data["summary"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.note = _data["note"] ? Note.fromJS(_data["note"]) : undefined as any;
            if (Array.isArray(_data["embeddings"])) {
                this.embeddings = [] as any;
                for (let item of _data["embeddings"])
                    this.embeddings!.push(Embedding.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NoteChunk {
        data = typeof data === 'object' ? data : {};
        let result = new NoteChunk();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["noteId"] = this.noteId;
        data["content"] = this.content;
        data["chunkIndex"] = this.chunkIndex;
        data["tokenCount"] = this.tokenCount;
        data["seq"] = this.seq;
        data["text"] = this.text;
        data["sha256"] = this.sha256;
        data["sensitivityLevel"] = this.sensitivityLevel;
        data["piiFlags"] = this.piiFlags;
        data["secretFlags"] = this.secretFlags;
        data["summary"] = this.summary;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["note"] = this.note ? this.note.toJSON() : undefined as any;
        if (Array.isArray(this.embeddings)) {
            data["embeddings"] = [];
            for (let item of this.embeddings)
                data["embeddings"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface INoteChunk {
    id?: string | undefined;
    noteId?: string | undefined;
    content?: string | undefined;
    chunkIndex?: number;
    tokenCount?: number;
    seq?: number;
    text?: string | undefined;
    sha256?: string | undefined;
    sensitivityLevel?: number;
    piiFlags?: string | undefined;
    secretFlags?: string | undefined;
    summary?: string | undefined;
    createdAt?: Date;
    note?: Note;
    embeddings?: Embedding[] | undefined;
}

export class NoteTag implements INoteTag {
    noteId?: string | undefined;
    tagId?: number;
    note?: Note;
    tag?: Tag;

    constructor(data?: INoteTag) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.noteId = _data["noteId"];
            this.tagId = _data["tagId"];
            this.note = _data["note"] ? Note.fromJS(_data["note"]) : undefined as any;
            this.tag = _data["tag"] ? Tag.fromJS(_data["tag"]) : undefined as any;
        }
    }

    static fromJS(data: any): NoteTag {
        data = typeof data === 'object' ? data : {};
        let result = new NoteTag();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["noteId"] = this.noteId;
        data["tagId"] = this.tagId;
        data["note"] = this.note ? this.note.toJSON() : undefined as any;
        data["tag"] = this.tag ? this.tag.toJSON() : undefined as any;
        return data;
    }
}

export interface INoteTag {
    noteId?: string | undefined;
    tagId?: number;
    note?: Note;
    tag?: Tag;
}

export class ProactiveSuggestion implements IProactiveSuggestion {
    type?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    actionUrl?: string | undefined;
    priority?: string | undefined;
    estimatedTimeMinutes?: number;

    constructor(data?: IProactiveSuggestion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.actionUrl = _data["actionUrl"];
            this.priority = _data["priority"];
            this.estimatedTimeMinutes = _data["estimatedTimeMinutes"];
        }
    }

    static fromJS(data: any): ProactiveSuggestion {
        data = typeof data === 'object' ? data : {};
        let result = new ProactiveSuggestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["description"] = this.description;
        data["actionUrl"] = this.actionUrl;
        data["priority"] = this.priority;
        data["estimatedTimeMinutes"] = this.estimatedTimeMinutes;
        return data;
    }
}

export interface IProactiveSuggestion {
    type?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    actionUrl?: string | undefined;
    priority?: string | undefined;
    estimatedTimeMinutes?: number;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class RagQueryRequest implements IRagQueryRequest {
    messages?: StringStringValueTuple[] | undefined;
    topK?: number;
    alpha?: number;
    filters?: { [key: string]: string; } | undefined;

    constructor(data?: IRagQueryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(StringStringValueTuple.fromJS(item));
            }
            this.topK = _data["topK"];
            this.alpha = _data["alpha"];
            if (_data["filters"]) {
                this.filters = {} as any;
                for (let key in _data["filters"]) {
                    if (_data["filters"].hasOwnProperty(key))
                        (this.filters as any)![key] = _data["filters"][key];
                }
            }
        }
    }

    static fromJS(data: any): RagQueryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RagQueryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item ? item.toJSON() : undefined as any);
        }
        data["topK"] = this.topK;
        data["alpha"] = this.alpha;
        if (this.filters) {
            data["filters"] = {};
            for (let key in this.filters) {
                if (this.filters.hasOwnProperty(key))
                    (data["filters"] as any)[key] = (this.filters as any)[key];
            }
        }
        return data;
    }
}

export interface IRagQueryRequest {
    messages?: StringStringValueTuple[] | undefined;
    topK?: number;
    alpha?: number;
    filters?: { [key: string]: string; } | undefined;
}

export class RedactionPolicyResponse implements IRedactionPolicyResponse {
    policies?: { [key: string]: any; } | undefined;
    defaultPolicy?: string | undefined;

    constructor(data?: IRedactionPolicyResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["policies"]) {
                this.policies = {} as any;
                for (let key in _data["policies"]) {
                    if (_data["policies"].hasOwnProperty(key))
                        (this.policies as any)![key] = _data["policies"][key];
                }
            }
            this.defaultPolicy = _data["defaultPolicy"];
        }
    }

    static fromJS(data: any): RedactionPolicyResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RedactionPolicyResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.policies) {
            data["policies"] = {};
            for (let key in this.policies) {
                if (this.policies.hasOwnProperty(key))
                    (data["policies"] as any)[key] = (this.policies as any)[key];
            }
        }
        data["defaultPolicy"] = this.defaultPolicy;
        return data;
    }
}

export interface IRedactionPolicyResponse {
    policies?: { [key: string]: any; } | undefined;
    defaultPolicy?: string | undefined;
}

export class RedactionPreviewRequest implements IRedactionPreviewRequest {
    noteId?: string | undefined;
    policy?: string | undefined;

    constructor(data?: IRedactionPreviewRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.noteId = _data["noteId"];
            this.policy = _data["policy"];
        }
    }

    static fromJS(data: any): RedactionPreviewRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RedactionPreviewRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["noteId"] = this.noteId;
        data["policy"] = this.policy;
        return data;
    }
}

export interface IRedactionPreviewRequest {
    noteId?: string | undefined;
    policy?: string | undefined;
}

export class RedactionPreviewResponse implements IRedactionPreviewResponse {
    noteId?: string | undefined;
    maskedText?: string | undefined;
    spans?: TextSpan[] | undefined;
    sensitivityLevel?: number;

    constructor(data?: IRedactionPreviewResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.noteId = _data["noteId"];
            this.maskedText = _data["maskedText"];
            if (Array.isArray(_data["spans"])) {
                this.spans = [] as any;
                for (let item of _data["spans"])
                    this.spans!.push(TextSpan.fromJS(item));
            }
            this.sensitivityLevel = _data["sensitivityLevel"];
        }
    }

    static fromJS(data: any): RedactionPreviewResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RedactionPreviewResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["noteId"] = this.noteId;
        data["maskedText"] = this.maskedText;
        if (Array.isArray(this.spans)) {
            data["spans"] = [];
            for (let item of this.spans)
                data["spans"].push(item ? item.toJSON() : undefined as any);
        }
        data["sensitivityLevel"] = this.sensitivityLevel;
        return data;
    }
}

export interface IRedactionPreviewResponse {
    noteId?: string | undefined;
    maskedText?: string | undefined;
    spans?: TextSpan[] | undefined;
    sensitivityLevel?: number;
}

export class SearchRequest implements ISearchRequest {
    q?: string | undefined;
    k?: number;
    filters?: { [key: string]: string; } | undefined;
    mode?: string | undefined;
    alpha?: number;

    constructor(data?: ISearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.q = _data["q"];
            this.k = _data["k"];
            if (_data["filters"]) {
                this.filters = {} as any;
                for (let key in _data["filters"]) {
                    if (_data["filters"].hasOwnProperty(key))
                        (this.filters as any)![key] = _data["filters"][key];
                }
            }
            this.mode = _data["mode"];
            this.alpha = _data["alpha"];
        }
    }

    static fromJS(data: any): SearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["q"] = this.q;
        data["k"] = this.k;
        if (this.filters) {
            data["filters"] = {};
            for (let key in this.filters) {
                if (this.filters.hasOwnProperty(key))
                    (data["filters"] as any)[key] = (this.filters as any)[key];
            }
        }
        data["mode"] = this.mode;
        data["alpha"] = this.alpha;
        return data;
    }
}

export interface ISearchRequest {
    q?: string | undefined;
    k?: number;
    filters?: { [key: string]: string; } | undefined;
    mode?: string | undefined;
    alpha?: number;
}

export class StringStringValueTuple implements IStringStringValueTuple {

    constructor(data?: IStringStringValueTuple) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): StringStringValueTuple {
        data = typeof data === 'object' ? data : {};
        let result = new StringStringValueTuple();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IStringStringValueTuple {
}

export class Tag implements ITag {
    id?: number;
    name?: string | undefined;
    noteTags?: NoteTag[] | undefined;

    constructor(data?: ITag) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["noteTags"])) {
                this.noteTags = [] as any;
                for (let item of _data["noteTags"])
                    this.noteTags!.push(NoteTag.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Tag {
        data = typeof data === 'object' ? data : {};
        let result = new Tag();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.noteTags)) {
            data["noteTags"] = [];
            for (let item of this.noteTags)
                data["noteTags"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface ITag {
    id?: number;
    name?: string | undefined;
    noteTags?: NoteTag[] | undefined;
}

export class TextSpan implements ITextSpan {
    id?: string | undefined;
    noteId?: string | undefined;
    start?: number;
    end?: number;
    label?: string | undefined;
    entityId?: string | undefined;
    confidence?: number;
    createdAt?: Date;
    note?: Note;
    entity?: Entity;

    constructor(data?: ITextSpan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.noteId = _data["noteId"];
            this.start = _data["start"];
            this.end = _data["end"];
            this.label = _data["label"];
            this.entityId = _data["entityId"];
            this.confidence = _data["confidence"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.note = _data["note"] ? Note.fromJS(_data["note"]) : undefined as any;
            this.entity = _data["entity"] ? Entity.fromJS(_data["entity"]) : undefined as any;
        }
    }

    static fromJS(data: any): TextSpan {
        data = typeof data === 'object' ? data : {};
        let result = new TextSpan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["noteId"] = this.noteId;
        data["start"] = this.start;
        data["end"] = this.end;
        data["label"] = this.label;
        data["entityId"] = this.entityId;
        data["confidence"] = this.confidence;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["note"] = this.note ? this.note.toJSON() : undefined as any;
        data["entity"] = this.entity ? this.entity.toJSON() : undefined as any;
        return data;
    }
}

export interface ITextSpan {
    id?: string | undefined;
    noteId?: string | undefined;
    start?: number;
    end?: number;
    label?: string | undefined;
    entityId?: string | undefined;
    confidence?: number;
    createdAt?: Date;
    note?: Note;
    entity?: Entity;
}

export class ToolRequest implements IToolRequest {
    tool?: string | undefined;
    parameters?: { [key: string]: any; } | undefined;
    requiresConfirmation?: boolean;

    constructor(data?: IToolRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tool = _data["tool"];
            if (_data["parameters"]) {
                this.parameters = {} as any;
                for (let key in _data["parameters"]) {
                    if (_data["parameters"].hasOwnProperty(key))
                        (this.parameters as any)![key] = _data["parameters"][key];
                }
            }
            this.requiresConfirmation = _data["requiresConfirmation"];
        }
    }

    static fromJS(data: any): ToolRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ToolRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tool"] = this.tool;
        if (this.parameters) {
            data["parameters"] = {};
            for (let key in this.parameters) {
                if (this.parameters.hasOwnProperty(key))
                    (data["parameters"] as any)[key] = (this.parameters as any)[key];
            }
        }
        data["requiresConfirmation"] = this.requiresConfirmation;
        return data;
    }
}

export interface IToolRequest {
    tool?: string | undefined;
    parameters?: { [key: string]: any; } | undefined;
    requiresConfirmation?: boolean;
}

export class ToolResult implements IToolResult {
    tool?: string | undefined;
    success?: boolean;
    result?: any | undefined;
    error?: string | undefined;
    executedAt?: Date;

    constructor(data?: IToolResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tool = _data["tool"];
            this.success = _data["success"];
            this.result = _data["result"];
            this.error = _data["error"];
            this.executedAt = _data["executedAt"] ? new Date(_data["executedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): ToolResult {
        data = typeof data === 'object' ? data : {};
        let result = new ToolResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tool"] = this.tool;
        data["success"] = this.success;
        data["result"] = this.result;
        data["error"] = this.error;
        data["executedAt"] = this.executedAt ? this.executedAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IToolResult {
    tool?: string | undefined;
    success?: boolean;
    result?: any | undefined;
    error?: string | undefined;
    executedAt?: Date;
}

export class UpdateUserProfileRequest implements IUpdateUserProfileRequest {
    email?: string | undefined;
    name?: string | undefined;
    bio?: string | undefined;
    avatar?: string | undefined;

    constructor(data?: IUpdateUserProfileRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.name = _data["name"];
            this.bio = _data["bio"];
            this.avatar = _data["avatar"];
        }
    }

    static fromJS(data: any): UpdateUserProfileRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserProfileRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["name"] = this.name;
        data["bio"] = this.bio;
        data["avatar"] = this.avatar;
        return data;
    }
}

export interface IUpdateUserProfileRequest {
    email?: string | undefined;
    name?: string | undefined;
    bio?: string | undefined;
    avatar?: string | undefined;
}

export class UserAchievement implements IUserAchievement {
    id?: string | undefined;
    userProfileId?: string | undefined;
    achievementId?: string | undefined;
    earnedAt?: Date;
    progress?: number;
    hasSeen?: boolean;
    userProfile?: UserProfile;
    achievement?: Achievement;

    constructor(data?: IUserAchievement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userProfileId = _data["userProfileId"];
            this.achievementId = _data["achievementId"];
            this.earnedAt = _data["earnedAt"] ? new Date(_data["earnedAt"].toString()) : undefined as any;
            this.progress = _data["progress"];
            this.hasSeen = _data["hasSeen"];
            this.userProfile = _data["userProfile"] ? UserProfile.fromJS(_data["userProfile"]) : undefined as any;
            this.achievement = _data["achievement"] ? Achievement.fromJS(_data["achievement"]) : undefined as any;
        }
    }

    static fromJS(data: any): UserAchievement {
        data = typeof data === 'object' ? data : {};
        let result = new UserAchievement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userProfileId"] = this.userProfileId;
        data["achievementId"] = this.achievementId;
        data["earnedAt"] = this.earnedAt ? this.earnedAt.toISOString() : undefined as any;
        data["progress"] = this.progress;
        data["hasSeen"] = this.hasSeen;
        data["userProfile"] = this.userProfile ? this.userProfile.toJSON() : undefined as any;
        data["achievement"] = this.achievement ? this.achievement.toJSON() : undefined as any;
        return data;
    }
}

export interface IUserAchievement {
    id?: string | undefined;
    userProfileId?: string | undefined;
    achievementId?: string | undefined;
    earnedAt?: Date;
    progress?: number;
    hasSeen?: boolean;
    userProfile?: UserProfile;
    achievement?: Achievement;
}

export class UserAchievementExport implements IUserAchievementExport {
    id?: string | undefined;
    earnedAt?: Date;
    progress?: number;
    hasSeen?: boolean;
    achievement?: Achievement;

    constructor(data?: IUserAchievementExport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.earnedAt = _data["earnedAt"] ? new Date(_data["earnedAt"].toString()) : undefined as any;
            this.progress = _data["progress"];
            this.hasSeen = _data["hasSeen"];
            this.achievement = _data["achievement"] ? Achievement.fromJS(_data["achievement"]) : undefined as any;
        }
    }

    static fromJS(data: any): UserAchievementExport {
        data = typeof data === 'object' ? data : {};
        let result = new UserAchievementExport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["earnedAt"] = this.earnedAt ? this.earnedAt.toISOString() : undefined as any;
        data["progress"] = this.progress;
        data["hasSeen"] = this.hasSeen;
        data["achievement"] = this.achievement ? this.achievement.toJSON() : undefined as any;
        return data;
    }
}

export interface IUserAchievementExport {
    id?: string | undefined;
    earnedAt?: Date;
    progress?: number;
    hasSeen?: boolean;
    achievement?: Achievement;
}

export class UserProfile implements IUserProfile {
    id?: string | undefined;
    subjectId?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;
    bio?: string | undefined;
    avatar?: string | undefined;
    preferences?: string | undefined;
    hasCompletedOnboarding?: boolean;
    lastLoginAt?: Date | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    totalNotes?: number;
    totalSearches?: number;
    totalLogins?: number;
    loginStreak?: number;
    lastStreakDate?: Date | undefined;
    totalTimeSpentMinutes?: number;
    experiencePoints?: number;
    level?: number;
    userAchievements?: UserAchievement[] | undefined;
    voicePinHash?: string | undefined;

    constructor(data?: IUserProfile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.subjectId = _data["subjectId"];
            this.email = _data["email"];
            this.name = _data["name"];
            this.bio = _data["bio"];
            this.avatar = _data["avatar"];
            this.preferences = _data["preferences"];
            this.hasCompletedOnboarding = _data["hasCompletedOnboarding"];
            this.lastLoginAt = _data["lastLoginAt"] ? new Date(_data["lastLoginAt"].toString()) : undefined as any;
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
            this.totalNotes = _data["totalNotes"];
            this.totalSearches = _data["totalSearches"];
            this.totalLogins = _data["totalLogins"];
            this.loginStreak = _data["loginStreak"];
            this.lastStreakDate = _data["lastStreakDate"] ? new Date(_data["lastStreakDate"].toString()) : undefined as any;
            this.totalTimeSpentMinutes = _data["totalTimeSpentMinutes"];
            this.experiencePoints = _data["experiencePoints"];
            this.level = _data["level"];
            if (Array.isArray(_data["userAchievements"])) {
                this.userAchievements = [] as any;
                for (let item of _data["userAchievements"])
                    this.userAchievements!.push(UserAchievement.fromJS(item));
            }
            this.voicePinHash = _data["voicePinHash"];
        }
    }

    static fromJS(data: any): UserProfile {
        data = typeof data === 'object' ? data : {};
        let result = new UserProfile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["subjectId"] = this.subjectId;
        data["email"] = this.email;
        data["name"] = this.name;
        data["bio"] = this.bio;
        data["avatar"] = this.avatar;
        data["preferences"] = this.preferences;
        data["hasCompletedOnboarding"] = this.hasCompletedOnboarding;
        data["lastLoginAt"] = this.lastLoginAt ? this.lastLoginAt.toISOString() : undefined as any;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        data["totalNotes"] = this.totalNotes;
        data["totalSearches"] = this.totalSearches;
        data["totalLogins"] = this.totalLogins;
        data["loginStreak"] = this.loginStreak;
        data["lastStreakDate"] = this.lastStreakDate ? this.lastStreakDate.toISOString() : undefined as any;
        data["totalTimeSpentMinutes"] = this.totalTimeSpentMinutes;
        data["experiencePoints"] = this.experiencePoints;
        data["level"] = this.level;
        if (Array.isArray(this.userAchievements)) {
            data["userAchievements"] = [];
            for (let item of this.userAchievements)
                data["userAchievements"].push(item ? item.toJSON() : undefined as any);
        }
        data["voicePinHash"] = this.voicePinHash;
        return data;
    }
}

export interface IUserProfile {
    id?: string | undefined;
    subjectId?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;
    bio?: string | undefined;
    avatar?: string | undefined;
    preferences?: string | undefined;
    hasCompletedOnboarding?: boolean;
    lastLoginAt?: Date | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    totalNotes?: number;
    totalSearches?: number;
    totalLogins?: number;
    loginStreak?: number;
    lastStreakDate?: Date | undefined;
    totalTimeSpentMinutes?: number;
    experiencePoints?: number;
    level?: number;
    userAchievements?: UserAchievement[] | undefined;
    voicePinHash?: string | undefined;
}

export class UserSettingsDto implements IUserSettingsDto {
    timezone?: string | undefined;
    language?: string | undefined;
    profileVisibility?: string | undefined;
    dataSharing?: boolean;
    analyticsOptIn?: boolean;
    searchHistory?: boolean;
    voiceEnabled?: boolean;
    wakeWord?: string | undefined;
    voiceLanguage?: string | undefined;
    voiceSpeed?: number;
    voiceVolume?: number;
    microphoneSensitivity?: number;
    continuousListening?: boolean;
    mascotEnabled?: boolean;
    mascotPersonality?: string | undefined;
    mascotAnimations?: boolean;
    mascotVoice?: boolean;
    mascotProactivity?: number;
    theme?: string | undefined;
    primaryColor?: string | undefined;
    fontSize?: string | undefined;
    reducedMotion?: boolean;
    highContrast?: boolean;
    emailNotifications?: boolean;
    pushNotifications?: boolean;
    achievementNotifications?: boolean;
    weeklyDigest?: boolean;
    maintenanceAlerts?: boolean;
    twoFactorEnabled?: boolean;
    loginAlerts?: boolean;
    sessionTimeout?: number;
    dataEncryption?: boolean;

    constructor(data?: IUserSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timezone = _data["timezone"];
            this.language = _data["language"];
            this.profileVisibility = _data["profileVisibility"];
            this.dataSharing = _data["dataSharing"];
            this.analyticsOptIn = _data["analyticsOptIn"];
            this.searchHistory = _data["searchHistory"];
            this.voiceEnabled = _data["voiceEnabled"];
            this.wakeWord = _data["wakeWord"];
            this.voiceLanguage = _data["voiceLanguage"];
            this.voiceSpeed = _data["voiceSpeed"];
            this.voiceVolume = _data["voiceVolume"];
            this.microphoneSensitivity = _data["microphoneSensitivity"];
            this.continuousListening = _data["continuousListening"];
            this.mascotEnabled = _data["mascotEnabled"];
            this.mascotPersonality = _data["mascotPersonality"];
            this.mascotAnimations = _data["mascotAnimations"];
            this.mascotVoice = _data["mascotVoice"];
            this.mascotProactivity = _data["mascotProactivity"];
            this.theme = _data["theme"];
            this.primaryColor = _data["primaryColor"];
            this.fontSize = _data["fontSize"];
            this.reducedMotion = _data["reducedMotion"];
            this.highContrast = _data["highContrast"];
            this.emailNotifications = _data["emailNotifications"];
            this.pushNotifications = _data["pushNotifications"];
            this.achievementNotifications = _data["achievementNotifications"];
            this.weeklyDigest = _data["weeklyDigest"];
            this.maintenanceAlerts = _data["maintenanceAlerts"];
            this.twoFactorEnabled = _data["twoFactorEnabled"];
            this.loginAlerts = _data["loginAlerts"];
            this.sessionTimeout = _data["sessionTimeout"];
            this.dataEncryption = _data["dataEncryption"];
        }
    }

    static fromJS(data: any): UserSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timezone"] = this.timezone;
        data["language"] = this.language;
        data["profileVisibility"] = this.profileVisibility;
        data["dataSharing"] = this.dataSharing;
        data["analyticsOptIn"] = this.analyticsOptIn;
        data["searchHistory"] = this.searchHistory;
        data["voiceEnabled"] = this.voiceEnabled;
        data["wakeWord"] = this.wakeWord;
        data["voiceLanguage"] = this.voiceLanguage;
        data["voiceSpeed"] = this.voiceSpeed;
        data["voiceVolume"] = this.voiceVolume;
        data["microphoneSensitivity"] = this.microphoneSensitivity;
        data["continuousListening"] = this.continuousListening;
        data["mascotEnabled"] = this.mascotEnabled;
        data["mascotPersonality"] = this.mascotPersonality;
        data["mascotAnimations"] = this.mascotAnimations;
        data["mascotVoice"] = this.mascotVoice;
        data["mascotProactivity"] = this.mascotProactivity;
        data["theme"] = this.theme;
        data["primaryColor"] = this.primaryColor;
        data["fontSize"] = this.fontSize;
        data["reducedMotion"] = this.reducedMotion;
        data["highContrast"] = this.highContrast;
        data["emailNotifications"] = this.emailNotifications;
        data["pushNotifications"] = this.pushNotifications;
        data["achievementNotifications"] = this.achievementNotifications;
        data["weeklyDigest"] = this.weeklyDigest;
        data["maintenanceAlerts"] = this.maintenanceAlerts;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        data["loginAlerts"] = this.loginAlerts;
        data["sessionTimeout"] = this.sessionTimeout;
        data["dataEncryption"] = this.dataEncryption;
        return data;
    }
}

export interface IUserSettingsDto {
    timezone?: string | undefined;
    language?: string | undefined;
    profileVisibility?: string | undefined;
    dataSharing?: boolean;
    analyticsOptIn?: boolean;
    searchHistory?: boolean;
    voiceEnabled?: boolean;
    wakeWord?: string | undefined;
    voiceLanguage?: string | undefined;
    voiceSpeed?: number;
    voiceVolume?: number;
    microphoneSensitivity?: number;
    continuousListening?: boolean;
    mascotEnabled?: boolean;
    mascotPersonality?: string | undefined;
    mascotAnimations?: boolean;
    mascotVoice?: boolean;
    mascotProactivity?: number;
    theme?: string | undefined;
    primaryColor?: string | undefined;
    fontSize?: string | undefined;
    reducedMotion?: boolean;
    highContrast?: boolean;
    emailNotifications?: boolean;
    pushNotifications?: boolean;
    achievementNotifications?: boolean;
    weeklyDigest?: boolean;
    maintenanceAlerts?: boolean;
    twoFactorEnabled?: boolean;
    loginAlerts?: boolean;
    sessionTimeout?: number;
    dataEncryption?: boolean;
}

export class VoicePinSetRequest implements IVoicePinSetRequest {
    pin?: string | undefined;
    userId?: string | undefined;

    constructor(data?: IVoicePinSetRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pin = _data["pin"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): VoicePinSetRequest {
        data = typeof data === 'object' ? data : {};
        let result = new VoicePinSetRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pin"] = this.pin;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IVoicePinSetRequest {
    pin?: string | undefined;
    userId?: string | undefined;
}

export class VoicePinSetResponse implements IVoicePinSetResponse {
    success?: boolean;
    message?: string | undefined;

    constructor(data?: IVoicePinSetResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): VoicePinSetResponse {
        data = typeof data === 'object' ? data : {};
        let result = new VoicePinSetResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        return data;
    }
}

export interface IVoicePinSetResponse {
    success?: boolean;
    message?: string | undefined;
}

export class VoicePinVerificationRequest implements IVoicePinVerificationRequest {
    pin?: string | undefined;
    userId?: string | undefined;

    constructor(data?: IVoicePinVerificationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pin = _data["pin"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): VoicePinVerificationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new VoicePinVerificationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pin"] = this.pin;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IVoicePinVerificationRequest {
    pin?: string | undefined;
    userId?: string | undefined;
}

export class VoicePinVerificationResponse implements IVoicePinVerificationResponse {
    isValid?: boolean;
    message?: string | undefined;

    constructor(data?: IVoicePinVerificationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isValid = _data["isValid"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): VoicePinVerificationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new VoicePinVerificationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isValid"] = this.isValid;
        data["message"] = this.message;
        return data;
    }
}

export interface IVoicePinVerificationResponse {
    isValid?: boolean;
    message?: string | undefined;
}

export class VoiceTtsRequest implements IVoiceTtsRequest {
    text?: string | undefined;

    constructor(data?: IVoiceTtsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): VoiceTtsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new VoiceTtsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        return data;
    }
}

export interface IVoiceTtsRequest {
    text?: string | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}