//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.7.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class CortexApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return Success
     */
    reindex(): Promise<void> {
        let url_ = this.baseUrl + "/api/Admin/reindex";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReindex(_response);
        });
    }

    protected processReindex(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    reembed(): Promise<void> {
        let url_ = this.baseUrl + "/api/Admin/reembed";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReembed(_response);
        });
    }

    protected processReembed(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    health(): Promise<void> {
        let url_ = this.baseUrl + "/api/Admin/health";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHealth(_response);
        });
    }

    protected processHealth(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    reindex2(body: EmbedReindexRequest | undefined): Promise<EmbedReindexResponse> {
        let url_ = this.baseUrl + "/api/Admin/embed/reindex";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReindex2(_response);
        });
    }

    protected processReindex2(response: Response): Promise<EmbedReindexResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmbedReindexResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EmbedReindexResponse>(null as any);
    }

    /**
     * @return Success
     */
    stats(): Promise<EmbedStatsResponse> {
        let url_ = this.baseUrl + "/api/Admin/embed/stats";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStats(_response);
        });
    }

    protected processStats(response: Response): Promise<EmbedStatsResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmbedStatsResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EmbedStatsResponse>(null as any);
    }

    /**
     * @return Success
     */
    listNotes(): Promise<void> {
        let url_ = this.baseUrl + "/api/Cards/list-notes";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListNotes(_response);
        });
    }

    protected processListNotes(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    note(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Cards/note/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNote(_response);
        });
    }

    protected processNote(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param action (optional) 
     * @return Success
     */
    confirmDelete(action: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Cards/confirm-delete?";
        if (action === null)
            throw new Error("The parameter 'action' cannot be null.");
        else if (action !== undefined)
            url_ += "action=" + encodeURIComponent("" + action) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processConfirmDelete(_response);
        });
    }

    protected processConfirmDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    tools(body: ChatToolsRequest | undefined): Promise<ChatToolsResponse> {
        let url_ = this.baseUrl + "/api/chat/tools";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTools(_response);
        });
    }

    protected processTools(response: Response): Promise<ChatToolsResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChatToolsResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ChatToolsResponse>(null as any);
    }

    /**
     * @return Success
     */
    toolsAll(): Promise<string[]> {
        let url_ = this.baseUrl + "/api/chat/tools";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processToolsAll(_response);
        });
    }

    protected processToolsAll(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    execute(body: ToolRequest | undefined): Promise<ToolResult> {
        let url_ = this.baseUrl + "/api/chat/tools/execute";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExecute(_response);
        });
    }

    protected processExecute(response: Response): Promise<ToolResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ToolResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ToolResult>(null as any);
    }

    /**
     * @return Success
     */
    classification(noteId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Classification/{noteId}";
        if (noteId === undefined || noteId === null)
            throw new Error("The parameter 'noteId' must be defined.");
        url_ = url_.replace("{noteId}", encodeURIComponent("" + noteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processClassification(_response);
        });
    }

    protected processClassification(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    bulk(body: BulkClassificationRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Classification/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBulk(_response);
        });
    }

    protected processBulk(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    achievements(): Promise<void> {
        let url_ = this.baseUrl + "/api/Gamification/achievements";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAchievements(_response);
        });
    }

    protected processAchievements(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    myAchievements(): Promise<void> {
        let url_ = this.baseUrl + "/api/Gamification/my-achievements";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMyAchievements(_response);
        });
    }

    protected processMyAchievements(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    stats2(): Promise<void> {
        let url_ = this.baseUrl + "/api/Gamification/stats";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStats2(_response);
        });
    }

    protected processStats2(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    progress(): Promise<void> {
        let url_ = this.baseUrl + "/api/Gamification/progress";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProgress(_response);
        });
    }

    protected processProgress(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    checkAchievements(): Promise<void> {
        let url_ = this.baseUrl + "/api/Gamification/check-achievements";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCheckAchievements(_response);
        });
    }

    protected processCheckAchievements(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    seed(): Promise<void> {
        let url_ = this.baseUrl + "/api/Gamification/seed";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSeed(_response);
        });
    }

    protected processSeed(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    allAchievements(): Promise<void> {
        let url_ = this.baseUrl + "/api/Gamification/all-achievements";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAllAchievements(_response);
        });
    }

    protected processAllAchievements(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param focus (optional) 
     * @param depth (optional) 
     * @param entityTypes (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @return Success
     */
    graph(focus: string | undefined, depth: number | undefined, entityTypes: string[] | undefined, fromDate: Date | undefined, toDate: Date | undefined): Promise<GraphResponse> {
        let url_ = this.baseUrl + "/api/Graph?";
        if (focus === null)
            throw new Error("The parameter 'focus' cannot be null.");
        else if (focus !== undefined)
            url_ += "focus=" + encodeURIComponent("" + focus) + "&";
        if (depth === null)
            throw new Error("The parameter 'depth' cannot be null.");
        else if (depth !== undefined)
            url_ += "depth=" + encodeURIComponent("" + depth) + "&";
        if (entityTypes === null)
            throw new Error("The parameter 'entityTypes' cannot be null.");
        else if (entityTypes !== undefined)
            entityTypes && entityTypes.forEach(item => { url_ += "entityTypes=" + encodeURIComponent("" + item) + "&"; });
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGraph(_response);
        });
    }

    protected processGraph(response: Response): Promise<GraphResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GraphResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GraphResponse>(null as any);
    }

    /**
     * @param depth (optional) 
     * @return Success
     */
    connected(entityId: string, depth: number | undefined): Promise<GraphNode[]> {
        let url_ = this.baseUrl + "/api/Graph/entities/{entityId}/connected?";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        if (depth === null)
            throw new Error("The parameter 'depth' cannot be null.");
        else if (depth !== undefined)
            url_ += "depth=" + encodeURIComponent("" + depth) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processConnected(_response);
        });
    }

    protected processConnected(response: Response): Promise<GraphNode[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GraphNode.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GraphNode[]>(null as any);
    }

    /**
     * @return Success
     */
    suggestions(entityId: string): Promise<string[]> {
        let url_ = this.baseUrl + "/api/Graph/entities/{entityId}/suggestions";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSuggestions(_response);
        });
    }

    protected processSuggestions(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }

    /**
     * @return Success
     */
    statistics(): Promise<{ [key: string]: number; }> {
        let url_ = this.baseUrl + "/api/Graph/statistics";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStatistics(_response);
        });
    }

    protected processStatistics(response: Response): Promise<{ [key: string]: number; }> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: number; }>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    extract(body: string | undefined): Promise<EntityExtraction[]> {
        let url_ = this.baseUrl + "/api/Graph/extract";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExtract(_response);
        });
    }

    protected processExtract(response: Response): Promise<EntityExtraction[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EntityExtraction.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EntityExtraction[]>(null as any);
    }

    /**
     * @return Success
     */
    coOccurrence(): Promise<void> {
        let url_ = this.baseUrl + "/api/Graph/discover/co-occurrence";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCoOccurrence(_response);
        });
    }

    protected processCoOccurrence(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    semantic(): Promise<void> {
        let url_ = this.baseUrl + "/api/Graph/discover/semantic";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSemantic(_response);
        });
    }

    protected processSemantic(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    temporal(): Promise<void> {
        let url_ = this.baseUrl + "/api/Graph/discover/temporal";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTemporal(_response);
        });
    }

    protected processTemporal(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    all(): Promise<void> {
        let url_ = this.baseUrl + "/api/Graph/discover/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAll(_response);
        });
    }

    protected processAll(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    insights(): Promise<GraphInsights> {
        let url_ = this.baseUrl + "/api/Graph/insights";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsights(_response);
        });
    }

    protected processInsights(response: Response): Promise<GraphInsights> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GraphInsights.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GraphInsights>(null as any);
    }

    /**
     * @return Success
     */
    health2(): Promise<void> {
        let url_ = this.baseUrl + "/api/Graph/health";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHealth2(_response);
        });
    }

    protected processHealth2(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    health3(): Promise<void> {
        let url_ = this.baseUrl + "/health";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHealth3(_response);
        });
    }

    protected processHealth3(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param files (optional) 
     * @return Success
     */
    files(files: FileParameter[] | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Ingest/files";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (files === null || files === undefined)
            throw new Error("The parameter 'files' cannot be null.");
        else
            files.forEach(item_ => content_.append("files", item_.data, item_.fileName ? item_.fileName : "files") );

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFiles(_response);
        });
    }

    protected processFiles(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    folder(body: FolderIngestRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Ingest/folder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFolder(_response);
        });
    }

    protected processFolder(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    graphEnrich(body: GraphEnrichJobPayload | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Jobs/graph-enrich";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGraphEnrich(_response);
        });
    }

    protected processGraphEnrich(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    graphEnrich2(noteId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Jobs/graph-enrich/{noteId}";
        if (noteId === undefined || noteId === null)
            throw new Error("The parameter 'noteId' must be defined.");
        url_ = url_.replace("{noteId}", encodeURIComponent("" + noteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGraphEnrich2(_response);
        });
    }

    protected processGraphEnrich2(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    pending(): Promise<JobDetails[]> {
        let url_ = this.baseUrl + "/api/Jobs/pending";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPending(_response);
        });
    }

    protected processPending(response: Response): Promise<JobDetails[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(JobDetails.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<JobDetails[]>(null as any);
    }

    /**
     * @return Success
     */
    status(): Promise<void> {
        let url_ = this.baseUrl + "/api/Jobs/status";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStatus(_response);
        });
    }

    protected processStatus(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    streamGET(): Promise<void> {
        let url_ = this.baseUrl + "/api/Jobs/status/stream";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStreamGET(_response);
        });
    }

    protected processStreamGET(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    notesGET(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Notes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNotesGET(_response);
        });
    }

    protected processNotesGET(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    notesDELETE(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Notes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNotesDELETE(_response);
        });
    }

    protected processNotesDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    notesPUT(id: string, body: UpdateNoteRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Notes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNotesPUT(_response);
        });
    }

    protected processNotesPUT(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param limit (optional) 
     * @param offset (optional) 
     * @param includeContent (optional) 
     * @return Success
     */
    notesGET2(limit: number | undefined, offset: number | undefined, includeContent: boolean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Notes?";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (includeContent === null)
            throw new Error("The parameter 'includeContent' cannot be null.");
        else if (includeContent !== undefined)
            url_ += "includeContent=" + encodeURIComponent("" + includeContent) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNotesGET2(_response);
        });
    }

    protected processNotesGET2(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    notesPOST(body: CreateNoteRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Notes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNotesPOST(_response);
        });
    }

    protected processNotesPOST(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    health4(): Promise<void> {
        let url_ = this.baseUrl + "/api/Notes/health";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHealth4(_response);
        });
    }

    protected processHealth4(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerDevicePOST(body: DeviceRegistrationRequest | undefined): Promise<DeviceRegistrationResponse> {
        let url_ = this.baseUrl + "/api/Notifications/register-device";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegisterDevicePOST(_response);
        });
    }

    protected processRegisterDevicePOST(response: Response): Promise<DeviceRegistrationResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceRegistrationResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeviceRegistrationResponse>(null as any);
    }

    /**
     * @return No Content
     */
    registerDeviceDELETE(deviceId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Notifications/register-device/{deviceId}";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegisterDeviceDELETE(_response);
        });
    }

    protected processRegisterDeviceDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    devices(): Promise<RegisteredDevice[]> {
        let url_ = this.baseUrl + "/api/Notifications/devices";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDevices(_response);
        });
    }

    protected processDevices(response: Response): Promise<RegisteredDevice[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RegisteredDevice.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RegisteredDevice[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    test(body: TestNotificationRequest | undefined): Promise<TestNotificationResponse> {
        let url_ = this.baseUrl + "/api/Notifications/test";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTest(_response);
        });
    }

    protected processTest(response: Response): Promise<TestNotificationResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TestNotificationResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TestNotificationResponse>(null as any);
    }

    /**
     * @param limit (optional) 
     * @param offset (optional) 
     * @return Success
     */
    history(limit: number | undefined, offset: number | undefined): Promise<NotificationHistoryResponse> {
        let url_ = this.baseUrl + "/api/Notifications/history?";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHistory(_response);
        });
    }

    protected processHistory(response: Response): Promise<NotificationHistoryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationHistoryResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationHistoryResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    preferencesPUT(body: NotificationPreferences | undefined): Promise<NotificationPreferences> {
        let url_ = this.baseUrl + "/api/Notifications/preferences";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPreferencesPUT(_response);
        });
    }

    protected processPreferencesPUT(response: Response): Promise<NotificationPreferences> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationPreferences.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationPreferences>(null as any);
    }

    /**
     * @return Success
     */
    preferencesGET(): Promise<NotificationPreferences> {
        let url_ = this.baseUrl + "/api/Notifications/preferences";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPreferencesGET(_response);
        });
    }

    protected processPreferencesGET(response: Response): Promise<NotificationPreferences> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationPreferences.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationPreferences>(null as any);
    }

    /**
     * @return Success
     */
    weeklyDigest(): Promise<void> {
        let url_ = this.baseUrl + "/api/Notifications/weekly-digest";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWeeklyDigest(_response);
        });
    }

    protected processWeeklyDigest(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    query(body: RagQueryRequest | undefined): Promise<RagAnswer> {
        let url_ = this.baseUrl + "/api/Rag/query";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processQuery(_response);
        });
    }

    protected processQuery(response: Response): Promise<RagAnswer> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RagAnswer.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status === 499) {
            return response.text().then((_responseText) => {
            let result499: any = null;
            let resultData499 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result499 = ProblemDetails.fromJS(resultData499);
            return throwException("Client Error", status, _responseText, _headers, result499);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Server Error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RagAnswer>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    streamPOST(body: RagQueryRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Rag/stream";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStreamPOST(_response);
        });
    }

    protected processStreamPOST(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    preview(body: RedactionPreviewRequest | undefined): Promise<RedactionPreviewResponse> {
        let url_ = this.baseUrl + "/api/Redaction/preview";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPreview(_response);
        });
    }

    protected processPreview(response: Response): Promise<RedactionPreviewResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RedactionPreviewResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RedactionPreviewResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    verifyPin(body: VoicePinVerificationRequest | undefined): Promise<VoicePinVerificationResponse> {
        let url_ = this.baseUrl + "/api/Redaction/verify-pin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processVerifyPin(_response);
        });
    }

    protected processVerifyPin(response: Response): Promise<VoicePinVerificationResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VoicePinVerificationResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VoicePinVerificationResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setPin(body: VoicePinSetRequest | undefined): Promise<VoicePinSetResponse> {
        let url_ = this.baseUrl + "/api/Redaction/set-pin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetPin(_response);
        });
    }

    protected processSetPin(response: Response): Promise<VoicePinSetResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VoicePinSetResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VoicePinSetResponse>(null as any);
    }

    /**
     * @return Success
     */
    policy(): Promise<RedactionPolicyResponse> {
        let url_ = this.baseUrl + "/api/Redaction/policy";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPolicy(_response);
        });
    }

    protected processPolicy(response: Response): Promise<RedactionPolicyResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RedactionPolicyResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RedactionPolicyResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchPOST(body: SearchRequest | undefined): Promise<SearchResponse> {
        let url_ = this.baseUrl + "/api/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchPOST(_response);
        });
    }

    protected processSearchPOST(response: Response): Promise<SearchResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SearchResponse>(null as any);
    }

    /**
     * @param q (optional) 
     * @param k (optional) 
     * @param offset (optional) 
     * @param mode (optional) 
     * @param alpha (optional) 
     * @return Success
     */
    searchGET(q: string | undefined, k: number | undefined, offset: number | undefined, mode: string | undefined, alpha: number | undefined): Promise<SearchResponse> {
        let url_ = this.baseUrl + "/api/Search?";
        if (q === null)
            throw new Error("The parameter 'q' cannot be null.");
        else if (q !== undefined)
            url_ += "q=" + encodeURIComponent("" + q) + "&";
        if (k === null)
            throw new Error("The parameter 'k' cannot be null.");
        else if (k !== undefined)
            url_ += "k=" + encodeURIComponent("" + k) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (mode === null)
            throw new Error("The parameter 'mode' cannot be null.");
        else if (mode !== undefined)
            url_ += "mode=" + encodeURIComponent("" + mode) + "&";
        if (alpha === null)
            throw new Error("The parameter 'alpha' cannot be null.");
        else if (alpha !== undefined)
            url_ += "alpha=" + encodeURIComponent("" + alpha) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchGET(_response);
        });
    }

    protected processSearchGET(response: Response): Promise<SearchResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SearchResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    advanced(body: AdvancedSearchRequest | undefined): Promise<SearchResponse> {
        let url_ = this.baseUrl + "/api/Search/advanced";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAdvanced(_response);
        });
    }

    protected processAdvanced(response: Response): Promise<SearchResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SearchResponse>(null as any);
    }

    /**
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param userId (optional) 
     * @return Success
     */
    audit(fromDate: Date | undefined, toDate: Date | undefined, userId: string | undefined): Promise<AuditEntry[]> {
        let url_ = this.baseUrl + "/api/Security/audit?";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAudit(_response);
        });
    }

    protected processAudit(response: Response): Promise<AuditEntry[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AuditEntry.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuditEntry[]>(null as any);
    }

    /**
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @return Success
     */
    summary(fromDate: Date | undefined, toDate: Date | undefined): Promise<AuditSummary> {
        let url_ = this.baseUrl + "/api/Security/audit/summary?";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSummary(_response);
        });
    }

    protected processSummary(response: Response): Promise<AuditSummary> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuditSummary.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuditSummary>(null as any);
    }

    /**
     * @param days (optional) 
     * @return Success
     */
    myActivity(days: number | undefined): Promise<AuditEntry[]> {
        let url_ = this.baseUrl + "/api/Security/my-activity?";
        if (days === null)
            throw new Error("The parameter 'days' cannot be null.");
        else if (days !== undefined)
            url_ += "days=" + encodeURIComponent("" + days) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMyActivity(_response);
        });
    }

    protected processMyActivity(response: Response): Promise<AuditEntry[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AuditEntry.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuditEntry[]>(null as any);
    }

    /**
     * @return Success
     */
    health5(): Promise<void> {
        let url_ = this.baseUrl + "/api/Security/health";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHealth5(_response);
        });
    }

    protected processHealth5(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    classificationReport(): Promise<void> {
        let url_ = this.baseUrl + "/api/Security/classification-report";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processClassificationReport(_response);
        });
    }

    protected processClassificationReport(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    seedData(): Promise<void> {
        let url_ = this.baseUrl + "/api/seed-data";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSeedData(_response);
        });
    }

    protected processSeedData(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param files (optional) 
     * @return Success
     */
    upload(files: FileParameter[] | undefined): Promise<UploadFilesResponse> {
        let url_ = this.baseUrl + "/api/Storage/upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (files === null || files === undefined)
            throw new Error("The parameter 'files' cannot be null.");
        else
            files.forEach(item_ => content_.append("files", item_.data, item_.fileName ? item_.fileName : "files") );

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpload(_response);
        });
    }

    protected processUpload(response: Response): Promise<UploadFilesResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UploadFilesResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result500 = resultData500 !== undefined ? resultData500 : <any>null;
    
            return throwException("Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UploadFilesResponse>(null as any);
    }

    /**
     * @param limit (optional) 
     * @param offset (optional) 
     * @return Success
     */
    storageGET(limit: number | undefined, offset: number | undefined): Promise<StorageListResponse> {
        let url_ = this.baseUrl + "/api/Storage?";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStorageGET(_response);
        });
    }

    protected processStorageGET(response: Response): Promise<StorageListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StorageListResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StorageListResponse>(null as any);
    }

    /**
     * @return Success
     */
    file(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Storage/file/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFile(_response);
        });
    }

    protected processFile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return No Content
     */
    storageDELETE(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Storage/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStorageDELETE(_response);
        });
    }

    protected processStorageDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 !== undefined ? resultData404 : <any>null;
    
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    today(): Promise<DailyDigest> {
        let url_ = this.baseUrl + "/api/Suggestions/digest/today";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processToday(_response);
        });
    }

    protected processToday(response: Response): Promise<DailyDigest> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DailyDigest.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DailyDigest>(null as any);
    }

    /**
     * @return Success
     */
    digest(date: Date): Promise<DailyDigest> {
        let url_ = this.baseUrl + "/api/Suggestions/digest/{date}";
        if (date === undefined || date === null)
            throw new Error("The parameter 'date' must be defined.");
        url_ = url_.replace("{date}", encodeURIComponent(date ? "" + date.toISOString() : "null"));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDigest(_response);
        });
    }

    protected processDigest(response: Response): Promise<DailyDigest> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DailyDigest.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DailyDigest>(null as any);
    }

    /**
     * @param limit (optional) 
     * @return Success
     */
    proactive(limit: number | undefined): Promise<ProactiveSuggestion[]> {
        let url_ = this.baseUrl + "/api/Suggestions/proactive?";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProactive(_response);
        });
    }

    protected processProactive(response: Response): Promise<ProactiveSuggestion[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProactiveSuggestion.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProactiveSuggestion[]>(null as any);
    }

    /**
     * @param days (optional) 
     * @param limit (optional) 
     * @return Success
     */
    trending(days: number | undefined, limit: number | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/Suggestions/trending?";
        if (days === null)
            throw new Error("The parameter 'days' cannot be null.");
        else if (days !== undefined)
            url_ += "days=" + encodeURIComponent("" + days) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTrending(_response);
        });
    }

    protected processTrending(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }

    /**
     * @param entityType (optional) 
     * @return Success
     */
    insightsAll(entityType: string | undefined): Promise<EntityInsight[]> {
        let url_ = this.baseUrl + "/api/Suggestions/entities/insights?";
        if (entityType === null)
            throw new Error("The parameter 'entityType' cannot be null.");
        else if (entityType !== undefined)
            url_ += "entityType=" + encodeURIComponent("" + entityType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInsightsAll(_response);
        });
    }

    protected processInsightsAll(response: Response): Promise<EntityInsight[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EntityInsight.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EntityInsight[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    assist(body: SuggestionRequest | undefined): Promise<SuggestionResponse> {
        let url_ = this.baseUrl + "/api/Suggestions/assist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAssist(_response);
        });
    }

    protected processAssist(response: Response): Promise<SuggestionResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SuggestionResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SuggestionResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    bulk2(body: BulkTagRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Tags/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBulk2(_response);
        });
    }

    protected processBulk2(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    tags(): Promise<TagsResponse> {
        let url_ = this.baseUrl + "/api/Tags";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTags(_response);
        });
    }

    protected processTags(response: Response): Promise<TagsResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TagsResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TagsResponse>(null as any);
    }

    /**
     * @return Success
     */
    tags2(noteId: string): Promise<NoteTagsResponse> {
        let url_ = this.baseUrl + "/api/Tags/{noteId}";
        if (noteId === undefined || noteId === null)
            throw new Error("The parameter 'noteId' must be defined.");
        url_ = url_.replace("{noteId}", encodeURIComponent("" + noteId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTags2(_response);
        });
    }

    protected processTags2(response: Response): Promise<NoteTagsResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NoteTagsResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NoteTagsResponse>(null as any);
    }

    /**
     * @param tags (optional) 
     * @param mode (optional) 
     * @param limit (optional) 
     * @param offset (optional) 
     * @return Success
     */
    search(tags: string | undefined, mode: string | undefined, limit: number | undefined, offset: number | undefined): Promise<TagSearchResponse> {
        let url_ = this.baseUrl + "/api/Tags/search?";
        if (tags === null)
            throw new Error("The parameter 'tags' cannot be null.");
        else if (tags !== undefined)
            url_ += "tags=" + encodeURIComponent("" + tags) + "&";
        if (mode === null)
            throw new Error("The parameter 'mode' cannot be null.");
        else if (mode !== undefined)
            url_ += "mode=" + encodeURIComponent("" + mode) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<TagSearchResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TagSearchResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TagSearchResponse>(null as any);
    }

    /**
     * @return Success
     */
    profileGET(): Promise<UserProfile> {
        let url_ = this.baseUrl + "/api/User/profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProfileGET(_response);
        });
    }

    protected processProfileGET(response: Response): Promise<UserProfile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserProfile.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserProfile>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    profilePOST(body: CreateUserProfileRequest | undefined): Promise<UserProfile> {
        let url_ = this.baseUrl + "/api/User/profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProfilePOST(_response);
        });
    }

    protected processProfilePOST(response: Response): Promise<UserProfile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserProfile.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserProfile>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    profilePUT(body: UpdateUserProfileRequest | undefined): Promise<UserProfile> {
        let url_ = this.baseUrl + "/api/User/profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProfilePUT(_response);
        });
    }

    protected processProfilePUT(response: Response): Promise<UserProfile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserProfile.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserProfile>(null as any);
    }

    /**
     * @return Success
     */
    profileDELETE(): Promise<void> {
        let url_ = this.baseUrl + "/api/User/profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProfileDELETE(_response);
        });
    }

    protected processProfileDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    settingsGET(): Promise<UserSettingsDto> {
        let url_ = this.baseUrl + "/api/User/settings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSettingsGET(_response);
        });
    }

    protected processSettingsGET(response: Response): Promise<UserSettingsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserSettingsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSettingsDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    settingsPUT(body: UserSettingsDto | undefined): Promise<UserSettingsDto> {
        let url_ = this.baseUrl + "/api/User/settings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSettingsPUT(_response);
        });
    }

    protected processSettingsPUT(response: Response): Promise<UserSettingsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserSettingsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSettingsDto>(null as any);
    }

    /**
     * @return Success
     */
    mascotProfileGET(): Promise<MascotProfileDto> {
        let url_ = this.baseUrl + "/api/User/mascot-profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMascotProfileGET(_response);
        });
    }

    protected processMascotProfileGET(response: Response): Promise<MascotProfileDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MascotProfileDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MascotProfileDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    mascotProfilePUT(body: UpdateMascotProfileRequest | undefined): Promise<MascotProfileDto> {
        let url_ = this.baseUrl + "/api/User/mascot-profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMascotProfilePUT(_response);
        });
    }

    protected processMascotProfilePUT(response: Response): Promise<MascotProfileDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MascotProfileDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MascotProfileDto>(null as any);
    }

    /**
     * @return Success
     */
    stt(): Promise<void> {
        let url_ = this.baseUrl + "/api/Voice/stt";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStt(_response);
        });
    }

    protected processStt(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    tts(body: VoiceTtsRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Voice/tts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTts(_response);
        });
    }

    protected processTts(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param text (optional) 
     * @param format (optional) 
     * @return Success
     */
    streamGET2(text: string | undefined, format: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Voice/tts/stream?";
        if (text === null)
            throw new Error("The parameter 'text' cannot be null.");
        else if (text !== undefined)
            url_ += "text=" + encodeURIComponent("" + text) + "&";
        if (format === null)
            throw new Error("The parameter 'format' cannot be null.");
        else if (format !== undefined)
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStreamGET2(_response);
        });
    }

    protected processStreamGET2(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    test2(body: VoiceTestRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Voice/test";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTest2(_response);
        });
    }

    protected processTest2(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    config(body: VoiceConfigRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Voice/config";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processConfig(_response);
        });
    }

    protected processConfig(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class Achievement implements IAchievement {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    icon?: string | undefined;
    category?: string | undefined;
    points?: number;
    isHidden?: boolean;
    sortOrder?: number;
    criteria?: string | undefined;
    createdAt?: Date;
    userAchievements?: UserAchievement[] | undefined;

    constructor(data?: IAchievement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.icon = _data["icon"];
            this.category = _data["category"];
            this.points = _data["points"];
            this.isHidden = _data["isHidden"];
            this.sortOrder = _data["sortOrder"];
            this.criteria = _data["criteria"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            if (Array.isArray(_data["userAchievements"])) {
                this.userAchievements = [] as any;
                for (let item of _data["userAchievements"])
                    this.userAchievements!.push(UserAchievement.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Achievement {
        data = typeof data === 'object' ? data : {};
        let result = new Achievement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["icon"] = this.icon;
        data["category"] = this.category;
        data["points"] = this.points;
        data["isHidden"] = this.isHidden;
        data["sortOrder"] = this.sortOrder;
        data["criteria"] = this.criteria;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        if (Array.isArray(this.userAchievements)) {
            data["userAchievements"] = [];
            for (let item of this.userAchievements)
                data["userAchievements"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAchievement {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    icon?: string | undefined;
    category?: string | undefined;
    points?: number;
    isHidden?: boolean;
    sortOrder?: number;
    criteria?: string | undefined;
    createdAt?: Date;
    userAchievements?: UserAchievement[] | undefined;
}

export class ActivitySummary implements IActivitySummary {
    notesCreated?: number;
    topCategories?: CategoryCount[] | undefined;
    trendingEntities?: EntityTrend[] | undefined;

    constructor(data?: IActivitySummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.notesCreated = _data["notesCreated"];
            if (Array.isArray(_data["topCategories"])) {
                this.topCategories = [] as any;
                for (let item of _data["topCategories"])
                    this.topCategories!.push(CategoryCount.fromJS(item));
            }
            if (Array.isArray(_data["trendingEntities"])) {
                this.trendingEntities = [] as any;
                for (let item of _data["trendingEntities"])
                    this.trendingEntities!.push(EntityTrend.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ActivitySummary {
        data = typeof data === 'object' ? data : {};
        let result = new ActivitySummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["notesCreated"] = this.notesCreated;
        if (Array.isArray(this.topCategories)) {
            data["topCategories"] = [];
            for (let item of this.topCategories)
                data["topCategories"].push(item.toJSON());
        }
        if (Array.isArray(this.trendingEntities)) {
            data["trendingEntities"] = [];
            for (let item of this.trendingEntities)
                data["trendingEntities"].push(item.toJSON());
        }
        return data;
    }
}

export interface IActivitySummary {
    notesCreated?: number;
    topCategories?: CategoryCount[] | undefined;
    trendingEntities?: EntityTrend[] | undefined;
}

export class AdvancedSearchRequest implements IAdvancedSearchRequest {
    q?: string | undefined;
    k?: number;
    offset?: number;
    mode?: string | undefined;
    alpha?: number;
    useReranking?: boolean;
    sensitivityLevels?: number[] | undefined;
    tags?: string[] | undefined;
    piiTypes?: string[] | undefined;
    secretTypes?: string[] | undefined;
    excludePii?: boolean;
    excludeSecrets?: boolean;
    dateFrom?: Date | undefined;
    dateTo?: Date | undefined;
    fileTypes?: string[] | undefined;
    source?: string | undefined;

    constructor(data?: IAdvancedSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.q = _data["q"];
            this.k = _data["k"];
            this.offset = _data["offset"];
            this.mode = _data["mode"];
            this.alpha = _data["alpha"];
            this.useReranking = _data["useReranking"];
            if (Array.isArray(_data["sensitivityLevels"])) {
                this.sensitivityLevels = [] as any;
                for (let item of _data["sensitivityLevels"])
                    this.sensitivityLevels!.push(item);
            }
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            if (Array.isArray(_data["piiTypes"])) {
                this.piiTypes = [] as any;
                for (let item of _data["piiTypes"])
                    this.piiTypes!.push(item);
            }
            if (Array.isArray(_data["secretTypes"])) {
                this.secretTypes = [] as any;
                for (let item of _data["secretTypes"])
                    this.secretTypes!.push(item);
            }
            this.excludePii = _data["excludePii"];
            this.excludeSecrets = _data["excludeSecrets"];
            this.dateFrom = _data["dateFrom"] ? new Date(_data["dateFrom"].toString()) : <any>undefined;
            this.dateTo = _data["dateTo"] ? new Date(_data["dateTo"].toString()) : <any>undefined;
            if (Array.isArray(_data["fileTypes"])) {
                this.fileTypes = [] as any;
                for (let item of _data["fileTypes"])
                    this.fileTypes!.push(item);
            }
            this.source = _data["source"];
        }
    }

    static fromJS(data: any): AdvancedSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AdvancedSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["q"] = this.q;
        data["k"] = this.k;
        data["offset"] = this.offset;
        data["mode"] = this.mode;
        data["alpha"] = this.alpha;
        data["useReranking"] = this.useReranking;
        if (Array.isArray(this.sensitivityLevels)) {
            data["sensitivityLevels"] = [];
            for (let item of this.sensitivityLevels)
                data["sensitivityLevels"].push(item);
        }
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        if (Array.isArray(this.piiTypes)) {
            data["piiTypes"] = [];
            for (let item of this.piiTypes)
                data["piiTypes"].push(item);
        }
        if (Array.isArray(this.secretTypes)) {
            data["secretTypes"] = [];
            for (let item of this.secretTypes)
                data["secretTypes"].push(item);
        }
        data["excludePii"] = this.excludePii;
        data["excludeSecrets"] = this.excludeSecrets;
        data["dateFrom"] = this.dateFrom ? this.dateFrom.toISOString() : <any>undefined;
        data["dateTo"] = this.dateTo ? this.dateTo.toISOString() : <any>undefined;
        if (Array.isArray(this.fileTypes)) {
            data["fileTypes"] = [];
            for (let item of this.fileTypes)
                data["fileTypes"].push(item);
        }
        data["source"] = this.source;
        return data;
    }
}

export interface IAdvancedSearchRequest {
    q?: string | undefined;
    k?: number;
    offset?: number;
    mode?: string | undefined;
    alpha?: number;
    useReranking?: boolean;
    sensitivityLevels?: number[] | undefined;
    tags?: string[] | undefined;
    piiTypes?: string[] | undefined;
    secretTypes?: string[] | undefined;
    excludePii?: boolean;
    excludeSecrets?: boolean;
    dateFrom?: Date | undefined;
    dateTo?: Date | undefined;
    fileTypes?: string[] | undefined;
    source?: string | undefined;
}

export class AuditEntry implements IAuditEntry {
    id?: string | undefined;
    userId?: string | undefined;
    action?: string | undefined;
    resourceType?: string | undefined;
    resourceId?: string | undefined;
    details?: string | undefined;
    ipAddress?: string | undefined;
    userAgent?: string | undefined;
    timestamp?: Date;

    constructor(data?: IAuditEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.action = _data["action"];
            this.resourceType = _data["resourceType"];
            this.resourceId = _data["resourceId"];
            this.details = _data["details"];
            this.ipAddress = _data["ipAddress"];
            this.userAgent = _data["userAgent"];
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AuditEntry {
        data = typeof data === 'object' ? data : {};
        let result = new AuditEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["action"] = this.action;
        data["resourceType"] = this.resourceType;
        data["resourceId"] = this.resourceId;
        data["details"] = this.details;
        data["ipAddress"] = this.ipAddress;
        data["userAgent"] = this.userAgent;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        return data;
    }
}

export interface IAuditEntry {
    id?: string | undefined;
    userId?: string | undefined;
    action?: string | undefined;
    resourceType?: string | undefined;
    resourceId?: string | undefined;
    details?: string | undefined;
    ipAddress?: string | undefined;
    userAgent?: string | undefined;
    timestamp?: Date;
}

export class AuditSummary implements IAuditSummary {
    fromDate?: Date;
    toDate?: Date;
    totalActions?: number;
    uniqueUsers?: number;
    actionBreakdown?: { [key: string]: number; } | undefined;
    resourceTypeBreakdown?: { [key: string]: number; } | undefined;
    sensitiveOperations?: number;
    topUsers?: UserActivity[] | undefined;
    generatedAt?: Date;

    constructor(data?: IAuditSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            this.totalActions = _data["totalActions"];
            this.uniqueUsers = _data["uniqueUsers"];
            if (_data["actionBreakdown"]) {
                this.actionBreakdown = {} as any;
                for (let key in _data["actionBreakdown"]) {
                    if (_data["actionBreakdown"].hasOwnProperty(key))
                        (<any>this.actionBreakdown)![key] = _data["actionBreakdown"][key];
                }
            }
            if (_data["resourceTypeBreakdown"]) {
                this.resourceTypeBreakdown = {} as any;
                for (let key in _data["resourceTypeBreakdown"]) {
                    if (_data["resourceTypeBreakdown"].hasOwnProperty(key))
                        (<any>this.resourceTypeBreakdown)![key] = _data["resourceTypeBreakdown"][key];
                }
            }
            this.sensitiveOperations = _data["sensitiveOperations"];
            if (Array.isArray(_data["topUsers"])) {
                this.topUsers = [] as any;
                for (let item of _data["topUsers"])
                    this.topUsers!.push(UserActivity.fromJS(item));
            }
            this.generatedAt = _data["generatedAt"] ? new Date(_data["generatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AuditSummary {
        data = typeof data === 'object' ? data : {};
        let result = new AuditSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["totalActions"] = this.totalActions;
        data["uniqueUsers"] = this.uniqueUsers;
        if (this.actionBreakdown) {
            data["actionBreakdown"] = {};
            for (let key in this.actionBreakdown) {
                if (this.actionBreakdown.hasOwnProperty(key))
                    (<any>data["actionBreakdown"])[key] = (<any>this.actionBreakdown)[key];
            }
        }
        if (this.resourceTypeBreakdown) {
            data["resourceTypeBreakdown"] = {};
            for (let key in this.resourceTypeBreakdown) {
                if (this.resourceTypeBreakdown.hasOwnProperty(key))
                    (<any>data["resourceTypeBreakdown"])[key] = (<any>this.resourceTypeBreakdown)[key];
            }
        }
        data["sensitiveOperations"] = this.sensitiveOperations;
        if (Array.isArray(this.topUsers)) {
            data["topUsers"] = [];
            for (let item of this.topUsers)
                data["topUsers"].push(item.toJSON());
        }
        data["generatedAt"] = this.generatedAt ? this.generatedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IAuditSummary {
    fromDate?: Date;
    toDate?: Date;
    totalActions?: number;
    uniqueUsers?: number;
    actionBreakdown?: { [key: string]: number; } | undefined;
    resourceTypeBreakdown?: { [key: string]: number; } | undefined;
    sensitiveOperations?: number;
    topUsers?: UserActivity[] | undefined;
    generatedAt?: Date;
}

export class BulkClassificationRequest implements IBulkClassificationRequest {
    noteIds?: string[] | undefined;

    constructor(data?: IBulkClassificationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["noteIds"])) {
                this.noteIds = [] as any;
                for (let item of _data["noteIds"])
                    this.noteIds!.push(item);
            }
        }
    }

    static fromJS(data: any): BulkClassificationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BulkClassificationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.noteIds)) {
            data["noteIds"] = [];
            for (let item of this.noteIds)
                data["noteIds"].push(item);
        }
        return data;
    }
}

export interface IBulkClassificationRequest {
    noteIds?: string[] | undefined;
}

export class BulkTagRequest implements IBulkTagRequest {
    noteIds?: string[] | undefined;
    add?: string[] | undefined;
    remove?: string[] | undefined;

    constructor(data?: IBulkTagRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["noteIds"])) {
                this.noteIds = [] as any;
                for (let item of _data["noteIds"])
                    this.noteIds!.push(item);
            }
            if (Array.isArray(_data["add"])) {
                this.add = [] as any;
                for (let item of _data["add"])
                    this.add!.push(item);
            }
            if (Array.isArray(_data["remove"])) {
                this.remove = [] as any;
                for (let item of _data["remove"])
                    this.remove!.push(item);
            }
        }
    }

    static fromJS(data: any): BulkTagRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BulkTagRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.noteIds)) {
            data["noteIds"] = [];
            for (let item of this.noteIds)
                data["noteIds"].push(item);
        }
        if (Array.isArray(this.add)) {
            data["add"] = [];
            for (let item of this.add)
                data["add"].push(item);
        }
        if (Array.isArray(this.remove)) {
            data["remove"] = [];
            for (let item of this.remove)
                data["remove"].push(item);
        }
        return data;
    }
}

export interface IBulkTagRequest {
    noteIds?: string[] | undefined;
    add?: string[] | undefined;
    remove?: string[] | undefined;
}

export class CategoryCount implements ICategoryCount {
    category?: string | undefined;
    count?: number;

    constructor(data?: ICategoryCount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.category = _data["category"];
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): CategoryCount {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryCount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        data["count"] = this.count;
        return data;
    }
}

export interface ICategoryCount {
    category?: string | undefined;
    count?: number;
}

export class ChatToolsRequest implements IChatToolsRequest {
    query?: string | undefined;
    availableTools?: string[] | undefined;
    context?: { [key: string]: any; } | undefined;

    constructor(data?: IChatToolsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.query = _data["query"];
            if (Array.isArray(_data["availableTools"])) {
                this.availableTools = [] as any;
                for (let item of _data["availableTools"])
                    this.availableTools!.push(item);
            }
            if (_data["context"]) {
                this.context = {} as any;
                for (let key in _data["context"]) {
                    if (_data["context"].hasOwnProperty(key))
                        (<any>this.context)![key] = _data["context"][key];
                }
            }
        }
    }

    static fromJS(data: any): ChatToolsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ChatToolsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["query"] = this.query;
        if (Array.isArray(this.availableTools)) {
            data["availableTools"] = [];
            for (let item of this.availableTools)
                data["availableTools"].push(item);
        }
        if (this.context) {
            data["context"] = {};
            for (let key in this.context) {
                if (this.context.hasOwnProperty(key))
                    (<any>data["context"])[key] = (<any>this.context)[key];
            }
        }
        return data;
    }
}

export interface IChatToolsRequest {
    query?: string | undefined;
    availableTools?: string[] | undefined;
    context?: { [key: string]: any; } | undefined;
}

export class ChatToolsResponse implements IChatToolsResponse {
    response?: string | undefined;
    suggestedTools?: ToolRequest[] | undefined;
    requiresConfirmation?: boolean;

    constructor(data?: IChatToolsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.response = _data["response"];
            if (Array.isArray(_data["suggestedTools"])) {
                this.suggestedTools = [] as any;
                for (let item of _data["suggestedTools"])
                    this.suggestedTools!.push(ToolRequest.fromJS(item));
            }
            this.requiresConfirmation = _data["requiresConfirmation"];
        }
    }

    static fromJS(data: any): ChatToolsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ChatToolsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["response"] = this.response;
        if (Array.isArray(this.suggestedTools)) {
            data["suggestedTools"] = [];
            for (let item of this.suggestedTools)
                data["suggestedTools"].push(item.toJSON());
        }
        data["requiresConfirmation"] = this.requiresConfirmation;
        return data;
    }
}

export interface IChatToolsResponse {
    response?: string | undefined;
    suggestedTools?: ToolRequest[] | undefined;
    requiresConfirmation?: boolean;
}

export class Classification implements IClassification {
    id?: string | undefined;
    noteId?: string | undefined;
    label?: string | undefined;
    score?: number;
    model?: string | undefined;
    createdAt?: Date;
    note?: Note;

    constructor(data?: IClassification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.noteId = _data["noteId"];
            this.label = _data["label"];
            this.score = _data["score"];
            this.model = _data["model"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.note = _data["note"] ? Note.fromJS(_data["note"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Classification {
        data = typeof data === 'object' ? data : {};
        let result = new Classification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["noteId"] = this.noteId;
        data["label"] = this.label;
        data["score"] = this.score;
        data["model"] = this.model;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["note"] = this.note ? this.note.toJSON() : <any>undefined;
        return data;
    }
}

export interface IClassification {
    id?: string | undefined;
    noteId?: string | undefined;
    label?: string | undefined;
    score?: number;
    model?: string | undefined;
    createdAt?: Date;
    note?: Note;
}

export class CreateNoteRequest implements ICreateNoteRequest {
    title?: string | undefined;
    content!: string;

    constructor(data?: ICreateNoteRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.content = _data["content"];
        }
    }

    static fromJS(data: any): CreateNoteRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateNoteRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["content"] = this.content;
        return data;
    }
}

export interface ICreateNoteRequest {
    title?: string | undefined;
    content: string;
}

export class CreateUserProfileRequest implements ICreateUserProfileRequest {
    email?: string | undefined;
    name?: string | undefined;
    subjectId?: string | undefined;
    bio?: string | undefined;
    avatar?: string | undefined;

    constructor(data?: ICreateUserProfileRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.name = _data["name"];
            this.subjectId = _data["subjectId"];
            this.bio = _data["bio"];
            this.avatar = _data["avatar"];
        }
    }

    static fromJS(data: any): CreateUserProfileRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserProfileRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["name"] = this.name;
        data["subjectId"] = this.subjectId;
        data["bio"] = this.bio;
        data["avatar"] = this.avatar;
        return data;
    }
}

export interface ICreateUserProfileRequest {
    email?: string | undefined;
    name?: string | undefined;
    subjectId?: string | undefined;
    bio?: string | undefined;
    avatar?: string | undefined;
}

export class DailyDigest implements IDailyDigest {
    date?: Date;
    summary?: string | undefined;
    recentActivity?: ActivitySummary;
    keyInsights?: string[] | undefined;
    proactiveSuggestions?: ProactiveSuggestion[] | undefined;
    entityClusters?: EntityCluster[] | undefined;
    generatedAt?: Date;

    constructor(data?: IDailyDigest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.summary = _data["summary"];
            this.recentActivity = _data["recentActivity"] ? ActivitySummary.fromJS(_data["recentActivity"]) : <any>undefined;
            if (Array.isArray(_data["keyInsights"])) {
                this.keyInsights = [] as any;
                for (let item of _data["keyInsights"])
                    this.keyInsights!.push(item);
            }
            if (Array.isArray(_data["proactiveSuggestions"])) {
                this.proactiveSuggestions = [] as any;
                for (let item of _data["proactiveSuggestions"])
                    this.proactiveSuggestions!.push(ProactiveSuggestion.fromJS(item));
            }
            if (Array.isArray(_data["entityClusters"])) {
                this.entityClusters = [] as any;
                for (let item of _data["entityClusters"])
                    this.entityClusters!.push(EntityCluster.fromJS(item));
            }
            this.generatedAt = _data["generatedAt"] ? new Date(_data["generatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DailyDigest {
        data = typeof data === 'object' ? data : {};
        let result = new DailyDigest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["summary"] = this.summary;
        data["recentActivity"] = this.recentActivity ? this.recentActivity.toJSON() : <any>undefined;
        if (Array.isArray(this.keyInsights)) {
            data["keyInsights"] = [];
            for (let item of this.keyInsights)
                data["keyInsights"].push(item);
        }
        if (Array.isArray(this.proactiveSuggestions)) {
            data["proactiveSuggestions"] = [];
            for (let item of this.proactiveSuggestions)
                data["proactiveSuggestions"].push(item.toJSON());
        }
        if (Array.isArray(this.entityClusters)) {
            data["entityClusters"] = [];
            for (let item of this.entityClusters)
                data["entityClusters"].push(item.toJSON());
        }
        data["generatedAt"] = this.generatedAt ? this.generatedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IDailyDigest {
    date?: Date;
    summary?: string | undefined;
    recentActivity?: ActivitySummary;
    keyInsights?: string[] | undefined;
    proactiveSuggestions?: ProactiveSuggestion[] | undefined;
    entityClusters?: EntityCluster[] | undefined;
    generatedAt?: Date;
}

export class DeviceRegistrationRequest implements IDeviceRegistrationRequest {
    endpoint?: string | undefined;
    p256dh?: string | undefined;
    auth?: string | undefined;
    deviceType?: string | undefined;
    deviceName?: string | undefined;
    userAgent?: string | undefined;

    constructor(data?: IDeviceRegistrationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.endpoint = _data["endpoint"];
            this.p256dh = _data["p256dh"];
            this.auth = _data["auth"];
            this.deviceType = _data["deviceType"];
            this.deviceName = _data["deviceName"];
            this.userAgent = _data["userAgent"];
        }
    }

    static fromJS(data: any): DeviceRegistrationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceRegistrationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["endpoint"] = this.endpoint;
        data["p256dh"] = this.p256dh;
        data["auth"] = this.auth;
        data["deviceType"] = this.deviceType;
        data["deviceName"] = this.deviceName;
        data["userAgent"] = this.userAgent;
        return data;
    }
}

export interface IDeviceRegistrationRequest {
    endpoint?: string | undefined;
    p256dh?: string | undefined;
    auth?: string | undefined;
    deviceType?: string | undefined;
    deviceName?: string | undefined;
    userAgent?: string | undefined;
}

export class DeviceRegistrationResponse implements IDeviceRegistrationResponse {
    deviceId?: string | undefined;
    success?: boolean;
    message?: string | undefined;
    registeredAt?: Date;

    constructor(data?: IDeviceRegistrationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.success = _data["success"];
            this.message = _data["message"];
            this.registeredAt = _data["registeredAt"] ? new Date(_data["registeredAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DeviceRegistrationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceRegistrationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["success"] = this.success;
        data["message"] = this.message;
        data["registeredAt"] = this.registeredAt ? this.registeredAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IDeviceRegistrationResponse {
    deviceId?: string | undefined;
    success?: boolean;
    message?: string | undefined;
    registeredAt?: Date;
}

export class Edge implements IEdge {
    id?: string | undefined;
    fromEntityId?: string | undefined;
    toEntityId?: string | undefined;
    relationType?: string | undefined;
    confidence?: number;
    source?: string | undefined;
    createdAt?: Date;
    fromEntity?: Entity;
    toEntity?: Entity;

    constructor(data?: IEdge) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fromEntityId = _data["fromEntityId"];
            this.toEntityId = _data["toEntityId"];
            this.relationType = _data["relationType"];
            this.confidence = _data["confidence"];
            this.source = _data["source"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.fromEntity = _data["fromEntity"] ? Entity.fromJS(_data["fromEntity"]) : <any>undefined;
            this.toEntity = _data["toEntity"] ? Entity.fromJS(_data["toEntity"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Edge {
        data = typeof data === 'object' ? data : {};
        let result = new Edge();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fromEntityId"] = this.fromEntityId;
        data["toEntityId"] = this.toEntityId;
        data["relationType"] = this.relationType;
        data["confidence"] = this.confidence;
        data["source"] = this.source;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["fromEntity"] = this.fromEntity ? this.fromEntity.toJSON() : <any>undefined;
        data["toEntity"] = this.toEntity ? this.toEntity.toJSON() : <any>undefined;
        return data;
    }
}

export interface IEdge {
    id?: string | undefined;
    fromEntityId?: string | undefined;
    toEntityId?: string | undefined;
    relationType?: string | undefined;
    confidence?: number;
    source?: string | undefined;
    createdAt?: Date;
    fromEntity?: Entity;
    toEntity?: Entity;
}

export class EmbedReindexRequest implements IEmbedReindexRequest {
    scope?: string | undefined;
    noteId?: string | undefined;
    since?: Date | undefined;

    constructor(data?: IEmbedReindexRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.scope = _data["scope"];
            this.noteId = _data["noteId"];
            this.since = _data["since"] ? new Date(_data["since"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): EmbedReindexRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EmbedReindexRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scope"] = this.scope;
        data["noteId"] = this.noteId;
        data["since"] = this.since ? this.since.toISOString() : <any>undefined;
        return data;
    }
}

export interface IEmbedReindexRequest {
    scope?: string | undefined;
    noteId?: string | undefined;
    since?: Date | undefined;
}

export class EmbedReindexResponse implements IEmbedReindexResponse {
    success?: boolean;
    processedCount?: number;
    errorCount?: number;
    errors?: string[] | undefined;
    durationMs?: number;
    completedAt?: Date;

    constructor(data?: IEmbedReindexResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.processedCount = _data["processedCount"];
            this.errorCount = _data["errorCount"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.durationMs = _data["durationMs"];
            this.completedAt = _data["completedAt"] ? new Date(_data["completedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): EmbedReindexResponse {
        data = typeof data === 'object' ? data : {};
        let result = new EmbedReindexResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["processedCount"] = this.processedCount;
        data["errorCount"] = this.errorCount;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["durationMs"] = this.durationMs;
        data["completedAt"] = this.completedAt ? this.completedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IEmbedReindexResponse {
    success?: boolean;
    processedCount?: number;
    errorCount?: number;
    errors?: string[] | undefined;
    durationMs?: number;
    completedAt?: Date;
}

export class EmbedStatsResponse implements IEmbedStatsResponse {
    totalNotes?: number;
    totalChunks?: number;
    totalEmbeddings?: number;
    chunksWithoutEmbeddings?: number;
    coveragePercentage?: number;
    newestEmbeddingAt?: Date | undefined;
    oldestEmbeddingAt?: Date | undefined;
    providerBreakdown?: { [key: string]: number; } | undefined;
    modelBreakdown?: { [key: string]: number; } | undefined;

    constructor(data?: IEmbedStatsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalNotes = _data["totalNotes"];
            this.totalChunks = _data["totalChunks"];
            this.totalEmbeddings = _data["totalEmbeddings"];
            this.chunksWithoutEmbeddings = _data["chunksWithoutEmbeddings"];
            this.coveragePercentage = _data["coveragePercentage"];
            this.newestEmbeddingAt = _data["newestEmbeddingAt"] ? new Date(_data["newestEmbeddingAt"].toString()) : <any>undefined;
            this.oldestEmbeddingAt = _data["oldestEmbeddingAt"] ? new Date(_data["oldestEmbeddingAt"].toString()) : <any>undefined;
            if (_data["providerBreakdown"]) {
                this.providerBreakdown = {} as any;
                for (let key in _data["providerBreakdown"]) {
                    if (_data["providerBreakdown"].hasOwnProperty(key))
                        (<any>this.providerBreakdown)![key] = _data["providerBreakdown"][key];
                }
            }
            if (_data["modelBreakdown"]) {
                this.modelBreakdown = {} as any;
                for (let key in _data["modelBreakdown"]) {
                    if (_data["modelBreakdown"].hasOwnProperty(key))
                        (<any>this.modelBreakdown)![key] = _data["modelBreakdown"][key];
                }
            }
        }
    }

    static fromJS(data: any): EmbedStatsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new EmbedStatsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalNotes"] = this.totalNotes;
        data["totalChunks"] = this.totalChunks;
        data["totalEmbeddings"] = this.totalEmbeddings;
        data["chunksWithoutEmbeddings"] = this.chunksWithoutEmbeddings;
        data["coveragePercentage"] = this.coveragePercentage;
        data["newestEmbeddingAt"] = this.newestEmbeddingAt ? this.newestEmbeddingAt.toISOString() : <any>undefined;
        data["oldestEmbeddingAt"] = this.oldestEmbeddingAt ? this.oldestEmbeddingAt.toISOString() : <any>undefined;
        if (this.providerBreakdown) {
            data["providerBreakdown"] = {};
            for (let key in this.providerBreakdown) {
                if (this.providerBreakdown.hasOwnProperty(key))
                    (<any>data["providerBreakdown"])[key] = (<any>this.providerBreakdown)[key];
            }
        }
        if (this.modelBreakdown) {
            data["modelBreakdown"] = {};
            for (let key in this.modelBreakdown) {
                if (this.modelBreakdown.hasOwnProperty(key))
                    (<any>data["modelBreakdown"])[key] = (<any>this.modelBreakdown)[key];
            }
        }
        return data;
    }
}

export interface IEmbedStatsResponse {
    totalNotes?: number;
    totalChunks?: number;
    totalEmbeddings?: number;
    chunksWithoutEmbeddings?: number;
    coveragePercentage?: number;
    newestEmbeddingAt?: Date | undefined;
    oldestEmbeddingAt?: Date | undefined;
    providerBreakdown?: { [key: string]: number; } | undefined;
    modelBreakdown?: { [key: string]: number; } | undefined;
}

export class Embedding implements IEmbedding {
    id?: string | undefined;
    chunkId?: string | undefined;
    provider?: string | undefined;
    model?: string | undefined;
    dim?: number;
    vectorRef?: string | undefined;
    createdAt?: Date;
    chunk?: NoteChunk;

    constructor(data?: IEmbedding) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.chunkId = _data["chunkId"];
            this.provider = _data["provider"];
            this.model = _data["model"];
            this.dim = _data["dim"];
            this.vectorRef = _data["vectorRef"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.chunk = _data["chunk"] ? NoteChunk.fromJS(_data["chunk"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Embedding {
        data = typeof data === 'object' ? data : {};
        let result = new Embedding();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["chunkId"] = this.chunkId;
        data["provider"] = this.provider;
        data["model"] = this.model;
        data["dim"] = this.dim;
        data["vectorRef"] = this.vectorRef;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["chunk"] = this.chunk ? this.chunk.toJSON() : <any>undefined;
        return data;
    }
}

export interface IEmbedding {
    id?: string | undefined;
    chunkId?: string | undefined;
    provider?: string | undefined;
    model?: string | undefined;
    dim?: number;
    vectorRef?: string | undefined;
    createdAt?: Date;
    chunk?: NoteChunk;
}

export class Entity implements IEntity {
    id?: string | undefined;
    type?: string | undefined;
    value?: string | undefined;
    canonicalValue?: string | undefined;
    canonicalEntityId?: string | undefined;
    confidenceScore?: number;
    mentionCount?: number;
    createdAt?: Date;
    lastSeenAt?: Date;
    canonicalEntity?: Entity;
    outgoingEdges?: Edge[] | undefined;
    incomingEdges?: Edge[] | undefined;

    constructor(data?: IEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.value = _data["value"];
            this.canonicalValue = _data["canonicalValue"];
            this.canonicalEntityId = _data["canonicalEntityId"];
            this.confidenceScore = _data["confidenceScore"];
            this.mentionCount = _data["mentionCount"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.lastSeenAt = _data["lastSeenAt"] ? new Date(_data["lastSeenAt"].toString()) : <any>undefined;
            this.canonicalEntity = _data["canonicalEntity"] ? Entity.fromJS(_data["canonicalEntity"]) : <any>undefined;
            if (Array.isArray(_data["outgoingEdges"])) {
                this.outgoingEdges = [] as any;
                for (let item of _data["outgoingEdges"])
                    this.outgoingEdges!.push(Edge.fromJS(item));
            }
            if (Array.isArray(_data["incomingEdges"])) {
                this.incomingEdges = [] as any;
                for (let item of _data["incomingEdges"])
                    this.incomingEdges!.push(Edge.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Entity {
        data = typeof data === 'object' ? data : {};
        let result = new Entity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["value"] = this.value;
        data["canonicalValue"] = this.canonicalValue;
        data["canonicalEntityId"] = this.canonicalEntityId;
        data["confidenceScore"] = this.confidenceScore;
        data["mentionCount"] = this.mentionCount;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["lastSeenAt"] = this.lastSeenAt ? this.lastSeenAt.toISOString() : <any>undefined;
        data["canonicalEntity"] = this.canonicalEntity ? this.canonicalEntity.toJSON() : <any>undefined;
        if (Array.isArray(this.outgoingEdges)) {
            data["outgoingEdges"] = [];
            for (let item of this.outgoingEdges)
                data["outgoingEdges"].push(item.toJSON());
        }
        if (Array.isArray(this.incomingEdges)) {
            data["incomingEdges"] = [];
            for (let item of this.incomingEdges)
                data["incomingEdges"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEntity {
    id?: string | undefined;
    type?: string | undefined;
    value?: string | undefined;
    canonicalValue?: string | undefined;
    canonicalEntityId?: string | undefined;
    confidenceScore?: number;
    mentionCount?: number;
    createdAt?: Date;
    lastSeenAt?: Date;
    canonicalEntity?: Entity;
    outgoingEdges?: Edge[] | undefined;
    incomingEdges?: Edge[] | undefined;
}

export class EntityCluster implements IEntityCluster {
    name?: string | undefined;
    entityTypes?: string[] | undefined;
    strength?: number;
    description?: string | undefined;

    constructor(data?: IEntityCluster) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["entityTypes"])) {
                this.entityTypes = [] as any;
                for (let item of _data["entityTypes"])
                    this.entityTypes!.push(item);
            }
            this.strength = _data["strength"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): EntityCluster {
        data = typeof data === 'object' ? data : {};
        let result = new EntityCluster();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.entityTypes)) {
            data["entityTypes"] = [];
            for (let item of this.entityTypes)
                data["entityTypes"].push(item);
        }
        data["strength"] = this.strength;
        data["description"] = this.description;
        return data;
    }
}

export interface IEntityCluster {
    name?: string | undefined;
    entityTypes?: string[] | undefined;
    strength?: number;
    description?: string | undefined;
}

export class EntityExtraction implements IEntityExtraction {
    type?: string | undefined;
    value?: string | undefined;
    start?: number;
    end?: number;
    confidence?: number;

    constructor(data?: IEntityExtraction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.value = _data["value"];
            this.start = _data["start"];
            this.end = _data["end"];
            this.confidence = _data["confidence"];
        }
    }

    static fromJS(data: any): EntityExtraction {
        data = typeof data === 'object' ? data : {};
        let result = new EntityExtraction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["value"] = this.value;
        data["start"] = this.start;
        data["end"] = this.end;
        data["confidence"] = this.confidence;
        return data;
    }
}

export interface IEntityExtraction {
    type?: string | undefined;
    value?: string | undefined;
    start?: number;
    end?: number;
    confidence?: number;
}

export class EntityInsight implements IEntityInsight {
    entityType?: string | undefined;
    entityValue?: string | undefined;
    frequency?: number;
    lastSeen?: Date;
    confidence?: number;

    constructor(data?: IEntityInsight) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityType = _data["entityType"];
            this.entityValue = _data["entityValue"];
            this.frequency = _data["frequency"];
            this.lastSeen = _data["lastSeen"] ? new Date(_data["lastSeen"].toString()) : <any>undefined;
            this.confidence = _data["confidence"];
        }
    }

    static fromJS(data: any): EntityInsight {
        data = typeof data === 'object' ? data : {};
        let result = new EntityInsight();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityType"] = this.entityType;
        data["entityValue"] = this.entityValue;
        data["frequency"] = this.frequency;
        data["lastSeen"] = this.lastSeen ? this.lastSeen.toISOString() : <any>undefined;
        data["confidence"] = this.confidence;
        return data;
    }
}

export interface IEntityInsight {
    entityType?: string | undefined;
    entityValue?: string | undefined;
    frequency?: number;
    lastSeen?: Date;
    confidence?: number;
}

export class EntityTrend implements IEntityTrend {
    entityType?: string | undefined;
    count?: number;
    trendDirection?: string | undefined;

    constructor(data?: IEntityTrend) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityType = _data["entityType"];
            this.count = _data["count"];
            this.trendDirection = _data["trendDirection"];
        }
    }

    static fromJS(data: any): EntityTrend {
        data = typeof data === 'object' ? data : {};
        let result = new EntityTrend();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityType"] = this.entityType;
        data["count"] = this.count;
        data["trendDirection"] = this.trendDirection;
        return data;
    }
}

export interface IEntityTrend {
    entityType?: string | undefined;
    count?: number;
    trendDirection?: string | undefined;
}

export class FolderIngestRequest implements IFolderIngestRequest {
    path?: string | undefined;

    constructor(data?: IFolderIngestRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.path = _data["path"];
        }
    }

    static fromJS(data: any): FolderIngestRequest {
        data = typeof data === 'object' ? data : {};
        let result = new FolderIngestRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["path"] = this.path;
        return data;
    }
}

export interface IFolderIngestRequest {
    path?: string | undefined;
}

export class GraphEdge implements IGraphEdge {
    id?: string | undefined;
    fromId?: string | undefined;
    toId?: string | undefined;
    relationType?: string | undefined;
    confidence?: number;

    constructor(data?: IGraphEdge) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fromId = _data["fromId"];
            this.toId = _data["toId"];
            this.relationType = _data["relationType"];
            this.confidence = _data["confidence"];
        }
    }

    static fromJS(data: any): GraphEdge {
        data = typeof data === 'object' ? data : {};
        let result = new GraphEdge();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fromId"] = this.fromId;
        data["toId"] = this.toId;
        data["relationType"] = this.relationType;
        data["confidence"] = this.confidence;
        return data;
    }
}

export interface IGraphEdge {
    id?: string | undefined;
    fromId?: string | undefined;
    toId?: string | undefined;
    relationType?: string | undefined;
    confidence?: number;
}

export class GraphEnrichJobPayload implements IGraphEnrichJobPayload {
    noteId?: string | undefined;

    constructor(data?: IGraphEnrichJobPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.noteId = _data["noteId"];
        }
    }

    static fromJS(data: any): GraphEnrichJobPayload {
        data = typeof data === 'object' ? data : {};
        let result = new GraphEnrichJobPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["noteId"] = this.noteId;
        return data;
    }
}

export interface IGraphEnrichJobPayload {
    noteId?: string | undefined;
}

export class GraphHub implements IGraphHub {
    entityId?: string | undefined;
    entityLabel?: string | undefined;
    entityType?: string | undefined;
    connectionCount?: number;

    constructor(data?: IGraphHub) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityId = _data["entityId"];
            this.entityLabel = _data["entityLabel"];
            this.entityType = _data["entityType"];
            this.connectionCount = _data["connectionCount"];
        }
    }

    static fromJS(data: any): GraphHub {
        data = typeof data === 'object' ? data : {};
        let result = new GraphHub();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityId"] = this.entityId;
        data["entityLabel"] = this.entityLabel;
        data["entityType"] = this.entityType;
        data["connectionCount"] = this.connectionCount;
        return data;
    }
}

export interface IGraphHub {
    entityId?: string | undefined;
    entityLabel?: string | undefined;
    entityType?: string | undefined;
    connectionCount?: number;
}

export class GraphInsights implements IGraphInsights {
    totalEntities?: number;
    totalRelationships?: number;
    connectedEntities?: number;
    isolatedEntities?: number;
    topHubs?: GraphHub[] | undefined;
    relationshipTypeDistribution?: { [key: string]: number; } | undefined;
    graphDensity?: number;
    generatedAt?: Date;

    constructor(data?: IGraphInsights) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalEntities = _data["totalEntities"];
            this.totalRelationships = _data["totalRelationships"];
            this.connectedEntities = _data["connectedEntities"];
            this.isolatedEntities = _data["isolatedEntities"];
            if (Array.isArray(_data["topHubs"])) {
                this.topHubs = [] as any;
                for (let item of _data["topHubs"])
                    this.topHubs!.push(GraphHub.fromJS(item));
            }
            if (_data["relationshipTypeDistribution"]) {
                this.relationshipTypeDistribution = {} as any;
                for (let key in _data["relationshipTypeDistribution"]) {
                    if (_data["relationshipTypeDistribution"].hasOwnProperty(key))
                        (<any>this.relationshipTypeDistribution)![key] = _data["relationshipTypeDistribution"][key];
                }
            }
            this.graphDensity = _data["graphDensity"];
            this.generatedAt = _data["generatedAt"] ? new Date(_data["generatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GraphInsights {
        data = typeof data === 'object' ? data : {};
        let result = new GraphInsights();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalEntities"] = this.totalEntities;
        data["totalRelationships"] = this.totalRelationships;
        data["connectedEntities"] = this.connectedEntities;
        data["isolatedEntities"] = this.isolatedEntities;
        if (Array.isArray(this.topHubs)) {
            data["topHubs"] = [];
            for (let item of this.topHubs)
                data["topHubs"].push(item.toJSON());
        }
        if (this.relationshipTypeDistribution) {
            data["relationshipTypeDistribution"] = {};
            for (let key in this.relationshipTypeDistribution) {
                if (this.relationshipTypeDistribution.hasOwnProperty(key))
                    (<any>data["relationshipTypeDistribution"])[key] = (<any>this.relationshipTypeDistribution)[key];
            }
        }
        data["graphDensity"] = this.graphDensity;
        data["generatedAt"] = this.generatedAt ? this.generatedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IGraphInsights {
    totalEntities?: number;
    totalRelationships?: number;
    connectedEntities?: number;
    isolatedEntities?: number;
    topHubs?: GraphHub[] | undefined;
    relationshipTypeDistribution?: { [key: string]: number; } | undefined;
    graphDensity?: number;
    generatedAt?: Date;
}

export class GraphNode implements IGraphNode {
    id?: string | undefined;
    type?: string | undefined;
    value?: string | undefined;
    connectionCount?: number;
    lastSeen?: Date;

    constructor(data?: IGraphNode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.value = _data["value"];
            this.connectionCount = _data["connectionCount"];
            this.lastSeen = _data["lastSeen"] ? new Date(_data["lastSeen"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GraphNode {
        data = typeof data === 'object' ? data : {};
        let result = new GraphNode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["value"] = this.value;
        data["connectionCount"] = this.connectionCount;
        data["lastSeen"] = this.lastSeen ? this.lastSeen.toISOString() : <any>undefined;
        return data;
    }
}

export interface IGraphNode {
    id?: string | undefined;
    type?: string | undefined;
    value?: string | undefined;
    connectionCount?: number;
    lastSeen?: Date;
}

export class GraphResponse implements IGraphResponse {
    nodes?: GraphNode[] | undefined;
    edges?: GraphEdge[] | undefined;
    totalNodes?: number;
    totalEdges?: number;

    constructor(data?: IGraphResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["nodes"])) {
                this.nodes = [] as any;
                for (let item of _data["nodes"])
                    this.nodes!.push(GraphNode.fromJS(item));
            }
            if (Array.isArray(_data["edges"])) {
                this.edges = [] as any;
                for (let item of _data["edges"])
                    this.edges!.push(GraphEdge.fromJS(item));
            }
            this.totalNodes = _data["totalNodes"];
            this.totalEdges = _data["totalEdges"];
        }
    }

    static fromJS(data: any): GraphResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GraphResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.nodes)) {
            data["nodes"] = [];
            for (let item of this.nodes)
                data["nodes"].push(item.toJSON());
        }
        if (Array.isArray(this.edges)) {
            data["edges"] = [];
            for (let item of this.edges)
                data["edges"].push(item.toJSON());
        }
        data["totalNodes"] = this.totalNodes;
        data["totalEdges"] = this.totalEdges;
        return data;
    }
}

export interface IGraphResponse {
    nodes?: GraphNode[] | undefined;
    edges?: GraphEdge[] | undefined;
    totalNodes?: number;
    totalEdges?: number;
}

export class JobDetails implements IJobDetails {
    id?: string | undefined;
    type?: string | undefined;
    stream?: string | undefined;
    enqueuedAt?: Date;
    payload?: { [key: string]: any; } | undefined;

    constructor(data?: IJobDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.stream = _data["stream"];
            this.enqueuedAt = _data["enqueuedAt"] ? new Date(_data["enqueuedAt"].toString()) : <any>undefined;
            if (_data["payload"]) {
                this.payload = {} as any;
                for (let key in _data["payload"]) {
                    if (_data["payload"].hasOwnProperty(key))
                        (<any>this.payload)![key] = _data["payload"][key];
                }
            }
        }
    }

    static fromJS(data: any): JobDetails {
        data = typeof data === 'object' ? data : {};
        let result = new JobDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["stream"] = this.stream;
        data["enqueuedAt"] = this.enqueuedAt ? this.enqueuedAt.toISOString() : <any>undefined;
        if (this.payload) {
            data["payload"] = {};
            for (let key in this.payload) {
                if (this.payload.hasOwnProperty(key))
                    (<any>data["payload"])[key] = (<any>this.payload)[key];
            }
        }
        return data;
    }
}

export interface IJobDetails {
    id?: string | undefined;
    type?: string | undefined;
    stream?: string | undefined;
    enqueuedAt?: Date;
    payload?: { [key: string]: any; } | undefined;
}

export class MascotInteraction implements IMascotInteraction {
    id?: string | undefined;
    type?: string | undefined;
    message?: string | undefined;
    userResponse?: string | undefined;
    timestamp?: Date;
    context?: { [key: string]: any; } | undefined;

    constructor(data?: IMascotInteraction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.message = _data["message"];
            this.userResponse = _data["userResponse"];
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            if (_data["context"]) {
                this.context = {} as any;
                for (let key in _data["context"]) {
                    if (_data["context"].hasOwnProperty(key))
                        (<any>this.context)![key] = _data["context"][key];
                }
            }
        }
    }

    static fromJS(data: any): MascotInteraction {
        data = typeof data === 'object' ? data : {};
        let result = new MascotInteraction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["message"] = this.message;
        data["userResponse"] = this.userResponse;
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        if (this.context) {
            data["context"] = {};
            for (let key in this.context) {
                if (this.context.hasOwnProperty(key))
                    (<any>data["context"])[key] = (<any>this.context)[key];
            }
        }
        return data;
    }
}

export interface IMascotInteraction {
    id?: string | undefined;
    type?: string | undefined;
    message?: string | undefined;
    userResponse?: string | undefined;
    timestamp?: Date;
    context?: { [key: string]: any; } | undefined;
}

export class MascotProfileDto implements IMascotProfileDto {
    enabled?: boolean;
    personality?: string | undefined;
    animations?: boolean;
    voice?: boolean;
    proactivity?: number;
    interactionHistory?: MascotInteraction[] | undefined;
    personalityQuirks?: string[] | undefined;
    customResponses?: string[] | undefined;

    constructor(data?: IMascotProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enabled = _data["enabled"];
            this.personality = _data["personality"];
            this.animations = _data["animations"];
            this.voice = _data["voice"];
            this.proactivity = _data["proactivity"];
            if (Array.isArray(_data["interactionHistory"])) {
                this.interactionHistory = [] as any;
                for (let item of _data["interactionHistory"])
                    this.interactionHistory!.push(MascotInteraction.fromJS(item));
            }
            if (Array.isArray(_data["personalityQuirks"])) {
                this.personalityQuirks = [] as any;
                for (let item of _data["personalityQuirks"])
                    this.personalityQuirks!.push(item);
            }
            if (Array.isArray(_data["customResponses"])) {
                this.customResponses = [] as any;
                for (let item of _data["customResponses"])
                    this.customResponses!.push(item);
            }
        }
    }

    static fromJS(data: any): MascotProfileDto {
        data = typeof data === 'object' ? data : {};
        let result = new MascotProfileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enabled"] = this.enabled;
        data["personality"] = this.personality;
        data["animations"] = this.animations;
        data["voice"] = this.voice;
        data["proactivity"] = this.proactivity;
        if (Array.isArray(this.interactionHistory)) {
            data["interactionHistory"] = [];
            for (let item of this.interactionHistory)
                data["interactionHistory"].push(item.toJSON());
        }
        if (Array.isArray(this.personalityQuirks)) {
            data["personalityQuirks"] = [];
            for (let item of this.personalityQuirks)
                data["personalityQuirks"].push(item);
        }
        if (Array.isArray(this.customResponses)) {
            data["customResponses"] = [];
            for (let item of this.customResponses)
                data["customResponses"].push(item);
        }
        return data;
    }
}

export interface IMascotProfileDto {
    enabled?: boolean;
    personality?: string | undefined;
    animations?: boolean;
    voice?: boolean;
    proactivity?: number;
    interactionHistory?: MascotInteraction[] | undefined;
    personalityQuirks?: string[] | undefined;
    customResponses?: string[] | undefined;
}

export class Note implements INote {
    id?: string | undefined;
    title?: string | undefined;
    userId?: string | undefined;
    content?: string | undefined;
    lang?: string | undefined;
    source?: string | undefined;
    isDeleted?: boolean;
    version?: number;
    sensitivityLevel?: number;
    piiFlags?: string | undefined;
    secretFlags?: string | undefined;
    summary?: string | undefined;
    originalPath?: string | undefined;
    filePath?: string | undefined;
    fileType?: string | undefined;
    sha256Hash?: string | undefined;
    fileSizeBytes?: number;
    createdAt?: Date;
    updatedAt?: Date;
    chunkCount?: number;
    tags?: string | undefined;
    chunks?: NoteChunk[] | undefined;
    noteTags?: NoteTag[] | undefined;
    classifications?: Classification[] | undefined;
    spans?: TextSpan[] | undefined;

    constructor(data?: INote) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.userId = _data["userId"];
            this.content = _data["content"];
            this.lang = _data["lang"];
            this.source = _data["source"];
            this.isDeleted = _data["isDeleted"];
            this.version = _data["version"];
            this.sensitivityLevel = _data["sensitivityLevel"];
            this.piiFlags = _data["piiFlags"];
            this.secretFlags = _data["secretFlags"];
            this.summary = _data["summary"];
            this.originalPath = _data["originalPath"];
            this.filePath = _data["filePath"];
            this.fileType = _data["fileType"];
            this.sha256Hash = _data["sha256Hash"];
            this.fileSizeBytes = _data["fileSizeBytes"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.chunkCount = _data["chunkCount"];
            this.tags = _data["tags"];
            if (Array.isArray(_data["chunks"])) {
                this.chunks = [] as any;
                for (let item of _data["chunks"])
                    this.chunks!.push(NoteChunk.fromJS(item));
            }
            if (Array.isArray(_data["noteTags"])) {
                this.noteTags = [] as any;
                for (let item of _data["noteTags"])
                    this.noteTags!.push(NoteTag.fromJS(item));
            }
            if (Array.isArray(_data["classifications"])) {
                this.classifications = [] as any;
                for (let item of _data["classifications"])
                    this.classifications!.push(Classification.fromJS(item));
            }
            if (Array.isArray(_data["spans"])) {
                this.spans = [] as any;
                for (let item of _data["spans"])
                    this.spans!.push(TextSpan.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Note {
        data = typeof data === 'object' ? data : {};
        let result = new Note();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["userId"] = this.userId;
        data["content"] = this.content;
        data["lang"] = this.lang;
        data["source"] = this.source;
        data["isDeleted"] = this.isDeleted;
        data["version"] = this.version;
        data["sensitivityLevel"] = this.sensitivityLevel;
        data["piiFlags"] = this.piiFlags;
        data["secretFlags"] = this.secretFlags;
        data["summary"] = this.summary;
        data["originalPath"] = this.originalPath;
        data["filePath"] = this.filePath;
        data["fileType"] = this.fileType;
        data["sha256Hash"] = this.sha256Hash;
        data["fileSizeBytes"] = this.fileSizeBytes;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["chunkCount"] = this.chunkCount;
        data["tags"] = this.tags;
        if (Array.isArray(this.chunks)) {
            data["chunks"] = [];
            for (let item of this.chunks)
                data["chunks"].push(item.toJSON());
        }
        if (Array.isArray(this.noteTags)) {
            data["noteTags"] = [];
            for (let item of this.noteTags)
                data["noteTags"].push(item.toJSON());
        }
        if (Array.isArray(this.classifications)) {
            data["classifications"] = [];
            for (let item of this.classifications)
                data["classifications"].push(item.toJSON());
        }
        if (Array.isArray(this.spans)) {
            data["spans"] = [];
            for (let item of this.spans)
                data["spans"].push(item.toJSON());
        }
        return data;
    }
}

export interface INote {
    id?: string | undefined;
    title?: string | undefined;
    userId?: string | undefined;
    content?: string | undefined;
    lang?: string | undefined;
    source?: string | undefined;
    isDeleted?: boolean;
    version?: number;
    sensitivityLevel?: number;
    piiFlags?: string | undefined;
    secretFlags?: string | undefined;
    summary?: string | undefined;
    originalPath?: string | undefined;
    filePath?: string | undefined;
    fileType?: string | undefined;
    sha256Hash?: string | undefined;
    fileSizeBytes?: number;
    createdAt?: Date;
    updatedAt?: Date;
    chunkCount?: number;
    tags?: string | undefined;
    chunks?: NoteChunk[] | undefined;
    noteTags?: NoteTag[] | undefined;
    classifications?: Classification[] | undefined;
    spans?: TextSpan[] | undefined;
}

export class NoteChunk implements INoteChunk {
    id?: string | undefined;
    noteId?: string | undefined;
    content?: string | undefined;
    chunkIndex?: number;
    tokenCount?: number;
    seq?: number;
    text?: string | undefined;
    sha256?: string | undefined;
    sensitivityLevel?: number;
    piiFlags?: string | undefined;
    secretFlags?: string | undefined;
    summary?: string | undefined;
    createdAt?: Date;
    note?: Note;
    embeddings?: Embedding[] | undefined;

    constructor(data?: INoteChunk) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.noteId = _data["noteId"];
            this.content = _data["content"];
            this.chunkIndex = _data["chunkIndex"];
            this.tokenCount = _data["tokenCount"];
            this.seq = _data["seq"];
            this.text = _data["text"];
            this.sha256 = _data["sha256"];
            this.sensitivityLevel = _data["sensitivityLevel"];
            this.piiFlags = _data["piiFlags"];
            this.secretFlags = _data["secretFlags"];
            this.summary = _data["summary"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.note = _data["note"] ? Note.fromJS(_data["note"]) : <any>undefined;
            if (Array.isArray(_data["embeddings"])) {
                this.embeddings = [] as any;
                for (let item of _data["embeddings"])
                    this.embeddings!.push(Embedding.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NoteChunk {
        data = typeof data === 'object' ? data : {};
        let result = new NoteChunk();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["noteId"] = this.noteId;
        data["content"] = this.content;
        data["chunkIndex"] = this.chunkIndex;
        data["tokenCount"] = this.tokenCount;
        data["seq"] = this.seq;
        data["text"] = this.text;
        data["sha256"] = this.sha256;
        data["sensitivityLevel"] = this.sensitivityLevel;
        data["piiFlags"] = this.piiFlags;
        data["secretFlags"] = this.secretFlags;
        data["summary"] = this.summary;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["note"] = this.note ? this.note.toJSON() : <any>undefined;
        if (Array.isArray(this.embeddings)) {
            data["embeddings"] = [];
            for (let item of this.embeddings)
                data["embeddings"].push(item.toJSON());
        }
        return data;
    }
}

export interface INoteChunk {
    id?: string | undefined;
    noteId?: string | undefined;
    content?: string | undefined;
    chunkIndex?: number;
    tokenCount?: number;
    seq?: number;
    text?: string | undefined;
    sha256?: string | undefined;
    sensitivityLevel?: number;
    piiFlags?: string | undefined;
    secretFlags?: string | undefined;
    summary?: string | undefined;
    createdAt?: Date;
    note?: Note;
    embeddings?: Embedding[] | undefined;
}

export class NoteMeta implements INoteMeta {
    id?: string | undefined;
    title?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    fileType?: string | undefined;
    sensitivityLevel?: number;
    chunkCount?: number;
    tags?: string[] | undefined;

    constructor(data?: INoteMeta) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.fileType = _data["fileType"];
            this.sensitivityLevel = _data["sensitivityLevel"];
            this.chunkCount = _data["chunkCount"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
        }
    }

    static fromJS(data: any): NoteMeta {
        data = typeof data === 'object' ? data : {};
        let result = new NoteMeta();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["fileType"] = this.fileType;
        data["sensitivityLevel"] = this.sensitivityLevel;
        data["chunkCount"] = this.chunkCount;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data;
    }
}

export interface INoteMeta {
    id?: string | undefined;
    title?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    fileType?: string | undefined;
    sensitivityLevel?: number;
    chunkCount?: number;
    tags?: string[] | undefined;
}

export class NoteTag implements INoteTag {
    noteId?: string | undefined;
    tagId?: number;
    note?: Note;
    tag?: Tag;

    constructor(data?: INoteTag) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.noteId = _data["noteId"];
            this.tagId = _data["tagId"];
            this.note = _data["note"] ? Note.fromJS(_data["note"]) : <any>undefined;
            this.tag = _data["tag"] ? Tag.fromJS(_data["tag"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NoteTag {
        data = typeof data === 'object' ? data : {};
        let result = new NoteTag();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["noteId"] = this.noteId;
        data["tagId"] = this.tagId;
        data["note"] = this.note ? this.note.toJSON() : <any>undefined;
        data["tag"] = this.tag ? this.tag.toJSON() : <any>undefined;
        return data;
    }
}

export interface INoteTag {
    noteId?: string | undefined;
    tagId?: number;
    note?: Note;
    tag?: Tag;
}

export class NoteTagsResponse implements INoteTagsResponse {
    noteId?: string | undefined;
    tags?: string[] | undefined;

    constructor(data?: INoteTagsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.noteId = _data["noteId"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
        }
    }

    static fromJS(data: any): NoteTagsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new NoteTagsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["noteId"] = this.noteId;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data;
    }
}

export interface INoteTagsResponse {
    noteId?: string | undefined;
    tags?: string[] | undefined;
}

export class NotificationHistoryEntry implements INotificationHistoryEntry {
    id?: string | undefined;
    type?: string | undefined;
    title?: string | undefined;
    message?: string | undefined;
    status?: string | undefined;
    deliveryMethods?: string[] | undefined;
    sentAt?: Date;
    readAt?: Date | undefined;

    constructor(data?: INotificationHistoryEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.title = _data["title"];
            this.message = _data["message"];
            this.status = _data["status"];
            if (Array.isArray(_data["deliveryMethods"])) {
                this.deliveryMethods = [] as any;
                for (let item of _data["deliveryMethods"])
                    this.deliveryMethods!.push(item);
            }
            this.sentAt = _data["sentAt"] ? new Date(_data["sentAt"].toString()) : <any>undefined;
            this.readAt = _data["readAt"] ? new Date(_data["readAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): NotificationHistoryEntry {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationHistoryEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["title"] = this.title;
        data["message"] = this.message;
        data["status"] = this.status;
        if (Array.isArray(this.deliveryMethods)) {
            data["deliveryMethods"] = [];
            for (let item of this.deliveryMethods)
                data["deliveryMethods"].push(item);
        }
        data["sentAt"] = this.sentAt ? this.sentAt.toISOString() : <any>undefined;
        data["readAt"] = this.readAt ? this.readAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface INotificationHistoryEntry {
    id?: string | undefined;
    type?: string | undefined;
    title?: string | undefined;
    message?: string | undefined;
    status?: string | undefined;
    deliveryMethods?: string[] | undefined;
    sentAt?: Date;
    readAt?: Date | undefined;
}

export class NotificationHistoryResponse implements INotificationHistoryResponse {
    notifications?: NotificationHistoryEntry[] | undefined;
    totalCount?: number;
    limit?: number;
    offset?: number;

    constructor(data?: INotificationHistoryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["notifications"])) {
                this.notifications = [] as any;
                for (let item of _data["notifications"])
                    this.notifications!.push(NotificationHistoryEntry.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.limit = _data["limit"];
            this.offset = _data["offset"];
        }
    }

    static fromJS(data: any): NotificationHistoryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationHistoryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.notifications)) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["limit"] = this.limit;
        data["offset"] = this.offset;
        return data;
    }
}

export interface INotificationHistoryResponse {
    notifications?: NotificationHistoryEntry[] | undefined;
    totalCount?: number;
    limit?: number;
    offset?: number;
}

export class NotificationPreferences implements INotificationPreferences {
    emailNotifications?: boolean;
    pushNotifications?: boolean;
    achievementNotifications?: boolean;
    weeklyDigest?: boolean;
    maintenanceAlerts?: boolean;
    noteReminders?: boolean;
    securityAlerts?: boolean;
    quietHoursStart?: string | undefined;
    quietHoursEnd?: string | undefined;
    timezone?: string | undefined;
    emailTypes?: string[] | undefined;
    pushTypes?: string[] | undefined;

    constructor(data?: INotificationPreferences) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailNotifications = _data["emailNotifications"];
            this.pushNotifications = _data["pushNotifications"];
            this.achievementNotifications = _data["achievementNotifications"];
            this.weeklyDigest = _data["weeklyDigest"];
            this.maintenanceAlerts = _data["maintenanceAlerts"];
            this.noteReminders = _data["noteReminders"];
            this.securityAlerts = _data["securityAlerts"];
            this.quietHoursStart = _data["quietHoursStart"];
            this.quietHoursEnd = _data["quietHoursEnd"];
            this.timezone = _data["timezone"];
            if (Array.isArray(_data["emailTypes"])) {
                this.emailTypes = [] as any;
                for (let item of _data["emailTypes"])
                    this.emailTypes!.push(item);
            }
            if (Array.isArray(_data["pushTypes"])) {
                this.pushTypes = [] as any;
                for (let item of _data["pushTypes"])
                    this.pushTypes!.push(item);
            }
        }
    }

    static fromJS(data: any): NotificationPreferences {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationPreferences();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailNotifications"] = this.emailNotifications;
        data["pushNotifications"] = this.pushNotifications;
        data["achievementNotifications"] = this.achievementNotifications;
        data["weeklyDigest"] = this.weeklyDigest;
        data["maintenanceAlerts"] = this.maintenanceAlerts;
        data["noteReminders"] = this.noteReminders;
        data["securityAlerts"] = this.securityAlerts;
        data["quietHoursStart"] = this.quietHoursStart;
        data["quietHoursEnd"] = this.quietHoursEnd;
        data["timezone"] = this.timezone;
        if (Array.isArray(this.emailTypes)) {
            data["emailTypes"] = [];
            for (let item of this.emailTypes)
                data["emailTypes"].push(item);
        }
        if (Array.isArray(this.pushTypes)) {
            data["pushTypes"] = [];
            for (let item of this.pushTypes)
                data["pushTypes"].push(item);
        }
        return data;
    }
}

export interface INotificationPreferences {
    emailNotifications?: boolean;
    pushNotifications?: boolean;
    achievementNotifications?: boolean;
    weeklyDigest?: boolean;
    maintenanceAlerts?: boolean;
    noteReminders?: boolean;
    securityAlerts?: boolean;
    quietHoursStart?: string | undefined;
    quietHoursEnd?: string | undefined;
    timezone?: string | undefined;
    emailTypes?: string[] | undefined;
    pushTypes?: string[] | undefined;
}

export class ProactiveSuggestion implements IProactiveSuggestion {
    type?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    actionUrl?: string | undefined;
    priority?: string | undefined;
    estimatedTimeMinutes?: number;

    constructor(data?: IProactiveSuggestion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.actionUrl = _data["actionUrl"];
            this.priority = _data["priority"];
            this.estimatedTimeMinutes = _data["estimatedTimeMinutes"];
        }
    }

    static fromJS(data: any): ProactiveSuggestion {
        data = typeof data === 'object' ? data : {};
        let result = new ProactiveSuggestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["description"] = this.description;
        data["actionUrl"] = this.actionUrl;
        data["priority"] = this.priority;
        data["estimatedTimeMinutes"] = this.estimatedTimeMinutes;
        return data;
    }
}

export interface IProactiveSuggestion {
    type?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    actionUrl?: string | undefined;
    priority?: string | undefined;
    estimatedTimeMinutes?: number;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class RagAnswer implements IRagAnswer {
    answer?: string | undefined;
    citations?: RagCitation[] | undefined;
    usage?: any | undefined;

    constructor(data?: IRagAnswer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.answer = _data["answer"];
            if (Array.isArray(_data["citations"])) {
                this.citations = [] as any;
                for (let item of _data["citations"])
                    this.citations!.push(RagCitation.fromJS(item));
            }
            this.usage = _data["usage"];
        }
    }

    static fromJS(data: any): RagAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new RagAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["answer"] = this.answer;
        if (Array.isArray(this.citations)) {
            data["citations"] = [];
            for (let item of this.citations)
                data["citations"].push(item.toJSON());
        }
        data["usage"] = this.usage;
        return data;
    }
}

export interface IRagAnswer {
    answer?: string | undefined;
    citations?: RagCitation[] | undefined;
    usage?: any | undefined;
}

export class RagCitation implements IRagCitation {
    noteId?: string | undefined;
    chunkId?: string | undefined;
    offsets?: number[] | undefined;

    constructor(data?: IRagCitation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.noteId = _data["noteId"];
            this.chunkId = _data["chunkId"];
            if (Array.isArray(_data["offsets"])) {
                this.offsets = [] as any;
                for (let item of _data["offsets"])
                    this.offsets!.push(item);
            }
        }
    }

    static fromJS(data: any): RagCitation {
        data = typeof data === 'object' ? data : {};
        let result = new RagCitation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["noteId"] = this.noteId;
        data["chunkId"] = this.chunkId;
        if (Array.isArray(this.offsets)) {
            data["offsets"] = [];
            for (let item of this.offsets)
                data["offsets"].push(item);
        }
        return data;
    }
}

export interface IRagCitation {
    noteId?: string | undefined;
    chunkId?: string | undefined;
    offsets?: number[] | undefined;
}

export class RagQueryRequest implements IRagQueryRequest {
    messages?: StringStringValueTuple[] | undefined;
    topK?: number;
    alpha?: number;
    filters?: { [key: string]: string; } | undefined;

    constructor(data?: IRagQueryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(StringStringValueTuple.fromJS(item));
            }
            this.topK = _data["topK"];
            this.alpha = _data["alpha"];
            if (_data["filters"]) {
                this.filters = {} as any;
                for (let key in _data["filters"]) {
                    if (_data["filters"].hasOwnProperty(key))
                        (<any>this.filters)![key] = _data["filters"][key];
                }
            }
        }
    }

    static fromJS(data: any): RagQueryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RagQueryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        data["topK"] = this.topK;
        data["alpha"] = this.alpha;
        if (this.filters) {
            data["filters"] = {};
            for (let key in this.filters) {
                if (this.filters.hasOwnProperty(key))
                    (<any>data["filters"])[key] = (<any>this.filters)[key];
            }
        }
        return data;
    }
}

export interface IRagQueryRequest {
    messages?: StringStringValueTuple[] | undefined;
    topK?: number;
    alpha?: number;
    filters?: { [key: string]: string; } | undefined;
}

export class RedactionPolicyResponse implements IRedactionPolicyResponse {
    policies?: { [key: string]: any; } | undefined;
    defaultPolicy?: string | undefined;

    constructor(data?: IRedactionPolicyResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["policies"]) {
                this.policies = {} as any;
                for (let key in _data["policies"]) {
                    if (_data["policies"].hasOwnProperty(key))
                        (<any>this.policies)![key] = _data["policies"][key];
                }
            }
            this.defaultPolicy = _data["defaultPolicy"];
        }
    }

    static fromJS(data: any): RedactionPolicyResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RedactionPolicyResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.policies) {
            data["policies"] = {};
            for (let key in this.policies) {
                if (this.policies.hasOwnProperty(key))
                    (<any>data["policies"])[key] = (<any>this.policies)[key];
            }
        }
        data["defaultPolicy"] = this.defaultPolicy;
        return data;
    }
}

export interface IRedactionPolicyResponse {
    policies?: { [key: string]: any; } | undefined;
    defaultPolicy?: string | undefined;
}

export class RedactionPreviewRequest implements IRedactionPreviewRequest {
    noteId?: string | undefined;
    policy?: string | undefined;

    constructor(data?: IRedactionPreviewRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.noteId = _data["noteId"];
            this.policy = _data["policy"];
        }
    }

    static fromJS(data: any): RedactionPreviewRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RedactionPreviewRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["noteId"] = this.noteId;
        data["policy"] = this.policy;
        return data;
    }
}

export interface IRedactionPreviewRequest {
    noteId?: string | undefined;
    policy?: string | undefined;
}

export class RedactionPreviewResponse implements IRedactionPreviewResponse {
    noteId?: string | undefined;
    maskedText?: string | undefined;
    spans?: TextSpan[] | undefined;
    sensitivityLevel?: number;

    constructor(data?: IRedactionPreviewResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.noteId = _data["noteId"];
            this.maskedText = _data["maskedText"];
            if (Array.isArray(_data["spans"])) {
                this.spans = [] as any;
                for (let item of _data["spans"])
                    this.spans!.push(TextSpan.fromJS(item));
            }
            this.sensitivityLevel = _data["sensitivityLevel"];
        }
    }

    static fromJS(data: any): RedactionPreviewResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RedactionPreviewResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["noteId"] = this.noteId;
        data["maskedText"] = this.maskedText;
        if (Array.isArray(this.spans)) {
            data["spans"] = [];
            for (let item of this.spans)
                data["spans"].push(item.toJSON());
        }
        data["sensitivityLevel"] = this.sensitivityLevel;
        return data;
    }
}

export interface IRedactionPreviewResponse {
    noteId?: string | undefined;
    maskedText?: string | undefined;
    spans?: TextSpan[] | undefined;
    sensitivityLevel?: number;
}

export class RegisteredDevice implements IRegisteredDevice {
    deviceId?: string | undefined;
    deviceType?: string | undefined;
    deviceName?: string | undefined;
    registeredAt?: Date;
    lastUsed?: Date | undefined;
    isActive?: boolean;

    constructor(data?: IRegisteredDevice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.deviceType = _data["deviceType"];
            this.deviceName = _data["deviceName"];
            this.registeredAt = _data["registeredAt"] ? new Date(_data["registeredAt"].toString()) : <any>undefined;
            this.lastUsed = _data["lastUsed"] ? new Date(_data["lastUsed"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): RegisteredDevice {
        data = typeof data === 'object' ? data : {};
        let result = new RegisteredDevice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["deviceType"] = this.deviceType;
        data["deviceName"] = this.deviceName;
        data["registeredAt"] = this.registeredAt ? this.registeredAt.toISOString() : <any>undefined;
        data["lastUsed"] = this.lastUsed ? this.lastUsed.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IRegisteredDevice {
    deviceId?: string | undefined;
    deviceType?: string | undefined;
    deviceName?: string | undefined;
    registeredAt?: Date;
    lastUsed?: Date | undefined;
    isActive?: boolean;
}

export class SearchHit implements ISearchHit {
    noteId?: string | undefined;
    chunkId?: string | undefined;
    title?: string | undefined;
    snippet?: string | undefined;
    content?: string | undefined;
    highlight?: string | undefined;
    offsets?: number[] | undefined;
    snippetStart?: number;
    chunkIndex?: number;
    score?: number;
    createdAt?: Date;
    source?: string | undefined;
    fileType?: string | undefined;
    sensitivityLevel?: number;
    tags?: string[] | undefined;
    hasPii?: boolean;
    hasSecrets?: boolean;
    piiTypes?: string[] | undefined;
    secretTypes?: string[] | undefined;

    constructor(data?: ISearchHit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.noteId = _data["noteId"];
            this.chunkId = _data["chunkId"];
            this.title = _data["title"];
            this.snippet = _data["snippet"];
            this.content = _data["content"];
            this.highlight = _data["highlight"];
            if (Array.isArray(_data["offsets"])) {
                this.offsets = [] as any;
                for (let item of _data["offsets"])
                    this.offsets!.push(item);
            }
            this.snippetStart = _data["snippetStart"];
            this.chunkIndex = _data["chunkIndex"];
            this.score = _data["score"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.source = _data["source"];
            this.fileType = _data["fileType"];
            this.sensitivityLevel = _data["sensitivityLevel"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            this.hasPii = _data["hasPii"];
            this.hasSecrets = _data["hasSecrets"];
            if (Array.isArray(_data["piiTypes"])) {
                this.piiTypes = [] as any;
                for (let item of _data["piiTypes"])
                    this.piiTypes!.push(item);
            }
            if (Array.isArray(_data["secretTypes"])) {
                this.secretTypes = [] as any;
                for (let item of _data["secretTypes"])
                    this.secretTypes!.push(item);
            }
        }
    }

    static fromJS(data: any): SearchHit {
        data = typeof data === 'object' ? data : {};
        let result = new SearchHit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["noteId"] = this.noteId;
        data["chunkId"] = this.chunkId;
        data["title"] = this.title;
        data["snippet"] = this.snippet;
        data["content"] = this.content;
        data["highlight"] = this.highlight;
        if (Array.isArray(this.offsets)) {
            data["offsets"] = [];
            for (let item of this.offsets)
                data["offsets"].push(item);
        }
        data["snippetStart"] = this.snippetStart;
        data["chunkIndex"] = this.chunkIndex;
        data["score"] = this.score;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["source"] = this.source;
        data["fileType"] = this.fileType;
        data["sensitivityLevel"] = this.sensitivityLevel;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["hasPii"] = this.hasPii;
        data["hasSecrets"] = this.hasSecrets;
        if (Array.isArray(this.piiTypes)) {
            data["piiTypes"] = [];
            for (let item of this.piiTypes)
                data["piiTypes"].push(item);
        }
        if (Array.isArray(this.secretTypes)) {
            data["secretTypes"] = [];
            for (let item of this.secretTypes)
                data["secretTypes"].push(item);
        }
        return data;
    }
}

export interface ISearchHit {
    noteId?: string | undefined;
    chunkId?: string | undefined;
    title?: string | undefined;
    snippet?: string | undefined;
    content?: string | undefined;
    highlight?: string | undefined;
    offsets?: number[] | undefined;
    snippetStart?: number;
    chunkIndex?: number;
    score?: number;
    createdAt?: Date;
    source?: string | undefined;
    fileType?: string | undefined;
    sensitivityLevel?: number;
    tags?: string[] | undefined;
    hasPii?: boolean;
    hasSecrets?: boolean;
    piiTypes?: string[] | undefined;
    secretTypes?: string[] | undefined;
}

export class SearchRequest implements ISearchRequest {
    q?: string | undefined;
    k?: number;
    offset?: number;
    filters?: { [key: string]: string; } | undefined;
    mode?: string | undefined;
    alpha?: number;

    constructor(data?: ISearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.q = _data["q"];
            this.k = _data["k"];
            this.offset = _data["offset"];
            if (_data["filters"]) {
                this.filters = {} as any;
                for (let key in _data["filters"]) {
                    if (_data["filters"].hasOwnProperty(key))
                        (<any>this.filters)![key] = _data["filters"][key];
                }
            }
            this.mode = _data["mode"];
            this.alpha = _data["alpha"];
        }
    }

    static fromJS(data: any): SearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["q"] = this.q;
        data["k"] = this.k;
        data["offset"] = this.offset;
        if (this.filters) {
            data["filters"] = {};
            for (let key in this.filters) {
                if (this.filters.hasOwnProperty(key))
                    (<any>data["filters"])[key] = (<any>this.filters)[key];
            }
        }
        data["mode"] = this.mode;
        data["alpha"] = this.alpha;
        return data;
    }
}

export interface ISearchRequest {
    q?: string | undefined;
    k?: number;
    offset?: number;
    filters?: { [key: string]: string; } | undefined;
    mode?: string | undefined;
    alpha?: number;
}

export class SearchResponse implements ISearchResponse {
    hits?: SearchHit[] | undefined;
    total?: number;
    offset?: number;
    k?: number;

    constructor(data?: ISearchResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["hits"])) {
                this.hits = [] as any;
                for (let item of _data["hits"])
                    this.hits!.push(SearchHit.fromJS(item));
            }
            this.total = _data["total"];
            this.offset = _data["offset"];
            this.k = _data["k"];
        }
    }

    static fromJS(data: any): SearchResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SearchResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.hits)) {
            data["hits"] = [];
            for (let item of this.hits)
                data["hits"].push(item.toJSON());
        }
        data["total"] = this.total;
        data["offset"] = this.offset;
        data["k"] = this.k;
        return data;
    }
}

export interface ISearchResponse {
    hits?: SearchHit[] | undefined;
    total?: number;
    offset?: number;
    k?: number;
}

export class StorageListResponse implements IStorageListResponse {
    total?: number;
    items?: StoredFileResponse[] | undefined;

    constructor(data?: IStorageListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.total = _data["total"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StoredFileResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StorageListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StorageListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IStorageListResponse {
    total?: number;
    items?: StoredFileResponse[] | undefined;
}

export class StoredFileResponse implements IStoredFileResponse {
    id?: string | undefined;
    fileName?: string | undefined;
    url?: string | undefined;
    sizeBytes?: number;
    contentType?: string | undefined;
    extension?: string | undefined;
    tags?: string[] | undefined;

    constructor(data?: IStoredFileResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fileName = _data["fileName"];
            this.url = _data["url"];
            this.sizeBytes = _data["sizeBytes"];
            this.contentType = _data["contentType"];
            this.extension = _data["extension"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
        }
    }

    static fromJS(data: any): StoredFileResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StoredFileResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fileName"] = this.fileName;
        data["url"] = this.url;
        data["sizeBytes"] = this.sizeBytes;
        data["contentType"] = this.contentType;
        data["extension"] = this.extension;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data;
    }
}

export interface IStoredFileResponse {
    id?: string | undefined;
    fileName?: string | undefined;
    url?: string | undefined;
    sizeBytes?: number;
    contentType?: string | undefined;
    extension?: string | undefined;
    tags?: string[] | undefined;
}

export class StringStringValueTuple implements IStringStringValueTuple {

    constructor(data?: IStringStringValueTuple) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): StringStringValueTuple {
        data = typeof data === 'object' ? data : {};
        let result = new StringStringValueTuple();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IStringStringValueTuple {
}

export class SuggestionRequest implements ISuggestionRequest {
    prompt?: string | undefined;
    context?: string | undefined;
    mode?: string | undefined;
    provider?: string | undefined;
    maxTokens?: number | undefined;
    temperature?: number | undefined;

    constructor(data?: ISuggestionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.prompt = _data["prompt"];
            this.context = _data["context"];
            this.mode = _data["mode"];
            this.provider = _data["provider"];
            this.maxTokens = _data["maxTokens"];
            this.temperature = _data["temperature"];
        }
    }

    static fromJS(data: any): SuggestionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SuggestionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["prompt"] = this.prompt;
        data["context"] = this.context;
        data["mode"] = this.mode;
        data["provider"] = this.provider;
        data["maxTokens"] = this.maxTokens;
        data["temperature"] = this.temperature;
        return data;
    }
}

export interface ISuggestionRequest {
    prompt?: string | undefined;
    context?: string | undefined;
    mode?: string | undefined;
    provider?: string | undefined;
    maxTokens?: number | undefined;
    temperature?: number | undefined;
}

export class SuggestionResponse implements ISuggestionResponse {
    text?: string | undefined;

    constructor(data?: ISuggestionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): SuggestionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SuggestionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        return data;
    }
}

export interface ISuggestionResponse {
    text?: string | undefined;
}

export class Tag implements ITag {
    id?: number;
    name?: string | undefined;
    noteTags?: NoteTag[] | undefined;

    constructor(data?: ITag) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["noteTags"])) {
                this.noteTags = [] as any;
                for (let item of _data["noteTags"])
                    this.noteTags!.push(NoteTag.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Tag {
        data = typeof data === 'object' ? data : {};
        let result = new Tag();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.noteTags)) {
            data["noteTags"] = [];
            for (let item of this.noteTags)
                data["noteTags"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITag {
    id?: number;
    name?: string | undefined;
    noteTags?: NoteTag[] | undefined;
}

export class TagInfo implements ITagInfo {
    name?: string | undefined;
    count?: number;

    constructor(data?: ITagInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): TagInfo {
        data = typeof data === 'object' ? data : {};
        let result = new TagInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["count"] = this.count;
        return data;
    }
}

export interface ITagInfo {
    name?: string | undefined;
    count?: number;
}

export class TagSearchResponse implements ITagSearchResponse {
    total?: number;
    offset?: number;
    limit?: number;
    items?: NoteMeta[] | undefined;

    constructor(data?: ITagSearchResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.total = _data["total"];
            this.offset = _data["offset"];
            this.limit = _data["limit"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(NoteMeta.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TagSearchResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TagSearchResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        data["offset"] = this.offset;
        data["limit"] = this.limit;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITagSearchResponse {
    total?: number;
    offset?: number;
    limit?: number;
    items?: NoteMeta[] | undefined;
}

export class TagsResponse implements ITagsResponse {
    tags?: TagInfo[] | undefined;

    constructor(data?: ITagsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(TagInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TagsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TagsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITagsResponse {
    tags?: TagInfo[] | undefined;
}

export class TestNotificationRequest implements ITestNotificationRequest {
    title?: string | undefined;
    message?: string | undefined;
    type?: string | undefined;

    constructor(data?: ITestNotificationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.message = _data["message"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): TestNotificationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TestNotificationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["message"] = this.message;
        data["type"] = this.type;
        return data;
    }
}

export interface ITestNotificationRequest {
    title?: string | undefined;
    message?: string | undefined;
    type?: string | undefined;
}

export class TestNotificationResponse implements ITestNotificationResponse {
    success?: boolean;
    successfulDeliveries?: number;
    failedDeliveries?: number;
    deliveryMethods?: string[] | undefined;
    errors?: string[] | undefined;
    sentAt?: Date;

    constructor(data?: ITestNotificationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.successfulDeliveries = _data["successfulDeliveries"];
            this.failedDeliveries = _data["failedDeliveries"];
            if (Array.isArray(_data["deliveryMethods"])) {
                this.deliveryMethods = [] as any;
                for (let item of _data["deliveryMethods"])
                    this.deliveryMethods!.push(item);
            }
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.sentAt = _data["sentAt"] ? new Date(_data["sentAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TestNotificationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TestNotificationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["successfulDeliveries"] = this.successfulDeliveries;
        data["failedDeliveries"] = this.failedDeliveries;
        if (Array.isArray(this.deliveryMethods)) {
            data["deliveryMethods"] = [];
            for (let item of this.deliveryMethods)
                data["deliveryMethods"].push(item);
        }
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["sentAt"] = this.sentAt ? this.sentAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface ITestNotificationResponse {
    success?: boolean;
    successfulDeliveries?: number;
    failedDeliveries?: number;
    deliveryMethods?: string[] | undefined;
    errors?: string[] | undefined;
    sentAt?: Date;
}

export class TextSpan implements ITextSpan {
    id?: string | undefined;
    noteId?: string | undefined;
    start?: number;
    end?: number;
    label?: string | undefined;
    entityId?: string | undefined;
    confidence?: number;
    createdAt?: Date;
    note?: Note;
    entity?: Entity;

    constructor(data?: ITextSpan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.noteId = _data["noteId"];
            this.start = _data["start"];
            this.end = _data["end"];
            this.label = _data["label"];
            this.entityId = _data["entityId"];
            this.confidence = _data["confidence"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.note = _data["note"] ? Note.fromJS(_data["note"]) : <any>undefined;
            this.entity = _data["entity"] ? Entity.fromJS(_data["entity"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TextSpan {
        data = typeof data === 'object' ? data : {};
        let result = new TextSpan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["noteId"] = this.noteId;
        data["start"] = this.start;
        data["end"] = this.end;
        data["label"] = this.label;
        data["entityId"] = this.entityId;
        data["confidence"] = this.confidence;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["note"] = this.note ? this.note.toJSON() : <any>undefined;
        data["entity"] = this.entity ? this.entity.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITextSpan {
    id?: string | undefined;
    noteId?: string | undefined;
    start?: number;
    end?: number;
    label?: string | undefined;
    entityId?: string | undefined;
    confidence?: number;
    createdAt?: Date;
    note?: Note;
    entity?: Entity;
}

export class ToolRequest implements IToolRequest {
    tool?: string | undefined;
    parameters?: { [key: string]: any; } | undefined;
    requiresConfirmation?: boolean;

    constructor(data?: IToolRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tool = _data["tool"];
            if (_data["parameters"]) {
                this.parameters = {} as any;
                for (let key in _data["parameters"]) {
                    if (_data["parameters"].hasOwnProperty(key))
                        (<any>this.parameters)![key] = _data["parameters"][key];
                }
            }
            this.requiresConfirmation = _data["requiresConfirmation"];
        }
    }

    static fromJS(data: any): ToolRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ToolRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tool"] = this.tool;
        if (this.parameters) {
            data["parameters"] = {};
            for (let key in this.parameters) {
                if (this.parameters.hasOwnProperty(key))
                    (<any>data["parameters"])[key] = (<any>this.parameters)[key];
            }
        }
        data["requiresConfirmation"] = this.requiresConfirmation;
        return data;
    }
}

export interface IToolRequest {
    tool?: string | undefined;
    parameters?: { [key: string]: any; } | undefined;
    requiresConfirmation?: boolean;
}

export class ToolResult implements IToolResult {
    tool?: string | undefined;
    success?: boolean;
    result?: any | undefined;
    error?: string | undefined;
    executedAt?: Date;

    constructor(data?: IToolResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tool = _data["tool"];
            this.success = _data["success"];
            this.result = _data["result"];
            this.error = _data["error"];
            this.executedAt = _data["executedAt"] ? new Date(_data["executedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ToolResult {
        data = typeof data === 'object' ? data : {};
        let result = new ToolResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tool"] = this.tool;
        data["success"] = this.success;
        data["result"] = this.result;
        data["error"] = this.error;
        data["executedAt"] = this.executedAt ? this.executedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IToolResult {
    tool?: string | undefined;
    success?: boolean;
    result?: any | undefined;
    error?: string | undefined;
    executedAt?: Date;
}

export class UpdateMascotProfileRequest implements IUpdateMascotProfileRequest {
    enabled?: boolean | undefined;
    personality?: string | undefined;
    animations?: boolean | undefined;
    voice?: boolean | undefined;
    proactivity?: number | undefined;

    constructor(data?: IUpdateMascotProfileRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enabled = _data["enabled"];
            this.personality = _data["personality"];
            this.animations = _data["animations"];
            this.voice = _data["voice"];
            this.proactivity = _data["proactivity"];
        }
    }

    static fromJS(data: any): UpdateMascotProfileRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMascotProfileRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enabled"] = this.enabled;
        data["personality"] = this.personality;
        data["animations"] = this.animations;
        data["voice"] = this.voice;
        data["proactivity"] = this.proactivity;
        return data;
    }
}

export interface IUpdateMascotProfileRequest {
    enabled?: boolean | undefined;
    personality?: string | undefined;
    animations?: boolean | undefined;
    voice?: boolean | undefined;
    proactivity?: number | undefined;
}

export class UpdateNoteRequest implements IUpdateNoteRequest {
    title?: string | undefined;
    content?: string | undefined;

    constructor(data?: IUpdateNoteRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.content = _data["content"];
        }
    }

    static fromJS(data: any): UpdateNoteRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateNoteRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["content"] = this.content;
        return data;
    }
}

export interface IUpdateNoteRequest {
    title?: string | undefined;
    content?: string | undefined;
}

export class UpdateUserProfileRequest implements IUpdateUserProfileRequest {
    email?: string | undefined;
    name?: string | undefined;
    bio?: string | undefined;
    avatar?: string | undefined;

    constructor(data?: IUpdateUserProfileRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.name = _data["name"];
            this.bio = _data["bio"];
            this.avatar = _data["avatar"];
        }
    }

    static fromJS(data: any): UpdateUserProfileRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserProfileRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["name"] = this.name;
        data["bio"] = this.bio;
        data["avatar"] = this.avatar;
        return data;
    }
}

export interface IUpdateUserProfileRequest {
    email?: string | undefined;
    name?: string | undefined;
    bio?: string | undefined;
    avatar?: string | undefined;
}

export class UploadFilesResponse implements IUploadFilesResponse {
    files?: StoredFileResponse[] | undefined;

    constructor(data?: IUploadFilesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(StoredFileResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UploadFilesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UploadFilesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUploadFilesResponse {
    files?: StoredFileResponse[] | undefined;
}

export class UserAchievement implements IUserAchievement {
    id?: string | undefined;
    userProfileId?: string | undefined;
    achievementId?: string | undefined;
    earnedAt?: Date;
    progress?: number;
    hasSeen?: boolean;
    userProfile?: UserProfile;
    achievement?: Achievement;

    constructor(data?: IUserAchievement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userProfileId = _data["userProfileId"];
            this.achievementId = _data["achievementId"];
            this.earnedAt = _data["earnedAt"] ? new Date(_data["earnedAt"].toString()) : <any>undefined;
            this.progress = _data["progress"];
            this.hasSeen = _data["hasSeen"];
            this.userProfile = _data["userProfile"] ? UserProfile.fromJS(_data["userProfile"]) : <any>undefined;
            this.achievement = _data["achievement"] ? Achievement.fromJS(_data["achievement"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserAchievement {
        data = typeof data === 'object' ? data : {};
        let result = new UserAchievement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userProfileId"] = this.userProfileId;
        data["achievementId"] = this.achievementId;
        data["earnedAt"] = this.earnedAt ? this.earnedAt.toISOString() : <any>undefined;
        data["progress"] = this.progress;
        data["hasSeen"] = this.hasSeen;
        data["userProfile"] = this.userProfile ? this.userProfile.toJSON() : <any>undefined;
        data["achievement"] = this.achievement ? this.achievement.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUserAchievement {
    id?: string | undefined;
    userProfileId?: string | undefined;
    achievementId?: string | undefined;
    earnedAt?: Date;
    progress?: number;
    hasSeen?: boolean;
    userProfile?: UserProfile;
    achievement?: Achievement;
}

export class UserActivity implements IUserActivity {
    userId?: string | undefined;
    actionCount?: number;

    constructor(data?: IUserActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.actionCount = _data["actionCount"];
        }
    }

    static fromJS(data: any): UserActivity {
        data = typeof data === 'object' ? data : {};
        let result = new UserActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["actionCount"] = this.actionCount;
        return data;
    }
}

export interface IUserActivity {
    userId?: string | undefined;
    actionCount?: number;
}

export class UserProfile implements IUserProfile {
    id?: string | undefined;
    subjectId?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;
    bio?: string | undefined;
    avatar?: string | undefined;
    preferences?: string | undefined;
    hasCompletedOnboarding?: boolean;
    lastLoginAt?: Date | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    totalNotes?: number;
    totalSearches?: number;
    totalLogins?: number;
    loginStreak?: number;
    lastStreakDate?: Date | undefined;
    totalTimeSpentMinutes?: number;
    experiencePoints?: number;
    level?: number;
    userAchievements?: UserAchievement[] | undefined;
    voicePinHash?: string | undefined;

    constructor(data?: IUserProfile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.subjectId = _data["subjectId"];
            this.email = _data["email"];
            this.name = _data["name"];
            this.bio = _data["bio"];
            this.avatar = _data["avatar"];
            this.preferences = _data["preferences"];
            this.hasCompletedOnboarding = _data["hasCompletedOnboarding"];
            this.lastLoginAt = _data["lastLoginAt"] ? new Date(_data["lastLoginAt"].toString()) : <any>undefined;
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.totalNotes = _data["totalNotes"];
            this.totalSearches = _data["totalSearches"];
            this.totalLogins = _data["totalLogins"];
            this.loginStreak = _data["loginStreak"];
            this.lastStreakDate = _data["lastStreakDate"] ? new Date(_data["lastStreakDate"].toString()) : <any>undefined;
            this.totalTimeSpentMinutes = _data["totalTimeSpentMinutes"];
            this.experiencePoints = _data["experiencePoints"];
            this.level = _data["level"];
            if (Array.isArray(_data["userAchievements"])) {
                this.userAchievements = [] as any;
                for (let item of _data["userAchievements"])
                    this.userAchievements!.push(UserAchievement.fromJS(item));
            }
            this.voicePinHash = _data["voicePinHash"];
        }
    }

    static fromJS(data: any): UserProfile {
        data = typeof data === 'object' ? data : {};
        let result = new UserProfile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["subjectId"] = this.subjectId;
        data["email"] = this.email;
        data["name"] = this.name;
        data["bio"] = this.bio;
        data["avatar"] = this.avatar;
        data["preferences"] = this.preferences;
        data["hasCompletedOnboarding"] = this.hasCompletedOnboarding;
        data["lastLoginAt"] = this.lastLoginAt ? this.lastLoginAt.toISOString() : <any>undefined;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["totalNotes"] = this.totalNotes;
        data["totalSearches"] = this.totalSearches;
        data["totalLogins"] = this.totalLogins;
        data["loginStreak"] = this.loginStreak;
        data["lastStreakDate"] = this.lastStreakDate ? this.lastStreakDate.toISOString() : <any>undefined;
        data["totalTimeSpentMinutes"] = this.totalTimeSpentMinutes;
        data["experiencePoints"] = this.experiencePoints;
        data["level"] = this.level;
        if (Array.isArray(this.userAchievements)) {
            data["userAchievements"] = [];
            for (let item of this.userAchievements)
                data["userAchievements"].push(item.toJSON());
        }
        data["voicePinHash"] = this.voicePinHash;
        return data;
    }
}

export interface IUserProfile {
    id?: string | undefined;
    subjectId?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;
    bio?: string | undefined;
    avatar?: string | undefined;
    preferences?: string | undefined;
    hasCompletedOnboarding?: boolean;
    lastLoginAt?: Date | undefined;
    createdAt?: Date;
    updatedAt?: Date;
    totalNotes?: number;
    totalSearches?: number;
    totalLogins?: number;
    loginStreak?: number;
    lastStreakDate?: Date | undefined;
    totalTimeSpentMinutes?: number;
    experiencePoints?: number;
    level?: number;
    userAchievements?: UserAchievement[] | undefined;
    voicePinHash?: string | undefined;
}

export class UserSettingsDto implements IUserSettingsDto {
    timezone?: string | undefined;
    language?: string | undefined;
    profileVisibility?: string | undefined;
    dataSharing?: boolean;
    analyticsOptIn?: boolean;
    searchHistory?: boolean;
    voiceEnabled?: boolean;
    wakeWord?: string | undefined;
    voiceLanguage?: string | undefined;
    voiceSpeed?: number;
    voiceVolume?: number;
    microphoneSensitivity?: number;
    continuousListening?: boolean;
    mascotEnabled?: boolean;
    mascotPersonality?: string | undefined;
    mascotAnimations?: boolean;
    mascotVoice?: boolean;
    mascotProactivity?: number;
    theme?: string | undefined;
    primaryColor?: string | undefined;
    fontSize?: string | undefined;
    reducedMotion?: boolean;
    highContrast?: boolean;
    emailNotifications?: boolean;
    pushNotifications?: boolean;
    achievementNotifications?: boolean;
    weeklyDigest?: boolean;
    maintenanceAlerts?: boolean;
    twoFactorEnabled?: boolean;
    loginAlerts?: boolean;
    sessionTimeout?: number;
    dataEncryption?: boolean;

    constructor(data?: IUserSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timezone = _data["timezone"];
            this.language = _data["language"];
            this.profileVisibility = _data["profileVisibility"];
            this.dataSharing = _data["dataSharing"];
            this.analyticsOptIn = _data["analyticsOptIn"];
            this.searchHistory = _data["searchHistory"];
            this.voiceEnabled = _data["voiceEnabled"];
            this.wakeWord = _data["wakeWord"];
            this.voiceLanguage = _data["voiceLanguage"];
            this.voiceSpeed = _data["voiceSpeed"];
            this.voiceVolume = _data["voiceVolume"];
            this.microphoneSensitivity = _data["microphoneSensitivity"];
            this.continuousListening = _data["continuousListening"];
            this.mascotEnabled = _data["mascotEnabled"];
            this.mascotPersonality = _data["mascotPersonality"];
            this.mascotAnimations = _data["mascotAnimations"];
            this.mascotVoice = _data["mascotVoice"];
            this.mascotProactivity = _data["mascotProactivity"];
            this.theme = _data["theme"];
            this.primaryColor = _data["primaryColor"];
            this.fontSize = _data["fontSize"];
            this.reducedMotion = _data["reducedMotion"];
            this.highContrast = _data["highContrast"];
            this.emailNotifications = _data["emailNotifications"];
            this.pushNotifications = _data["pushNotifications"];
            this.achievementNotifications = _data["achievementNotifications"];
            this.weeklyDigest = _data["weeklyDigest"];
            this.maintenanceAlerts = _data["maintenanceAlerts"];
            this.twoFactorEnabled = _data["twoFactorEnabled"];
            this.loginAlerts = _data["loginAlerts"];
            this.sessionTimeout = _data["sessionTimeout"];
            this.dataEncryption = _data["dataEncryption"];
        }
    }

    static fromJS(data: any): UserSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timezone"] = this.timezone;
        data["language"] = this.language;
        data["profileVisibility"] = this.profileVisibility;
        data["dataSharing"] = this.dataSharing;
        data["analyticsOptIn"] = this.analyticsOptIn;
        data["searchHistory"] = this.searchHistory;
        data["voiceEnabled"] = this.voiceEnabled;
        data["wakeWord"] = this.wakeWord;
        data["voiceLanguage"] = this.voiceLanguage;
        data["voiceSpeed"] = this.voiceSpeed;
        data["voiceVolume"] = this.voiceVolume;
        data["microphoneSensitivity"] = this.microphoneSensitivity;
        data["continuousListening"] = this.continuousListening;
        data["mascotEnabled"] = this.mascotEnabled;
        data["mascotPersonality"] = this.mascotPersonality;
        data["mascotAnimations"] = this.mascotAnimations;
        data["mascotVoice"] = this.mascotVoice;
        data["mascotProactivity"] = this.mascotProactivity;
        data["theme"] = this.theme;
        data["primaryColor"] = this.primaryColor;
        data["fontSize"] = this.fontSize;
        data["reducedMotion"] = this.reducedMotion;
        data["highContrast"] = this.highContrast;
        data["emailNotifications"] = this.emailNotifications;
        data["pushNotifications"] = this.pushNotifications;
        data["achievementNotifications"] = this.achievementNotifications;
        data["weeklyDigest"] = this.weeklyDigest;
        data["maintenanceAlerts"] = this.maintenanceAlerts;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        data["loginAlerts"] = this.loginAlerts;
        data["sessionTimeout"] = this.sessionTimeout;
        data["dataEncryption"] = this.dataEncryption;
        return data;
    }
}

export interface IUserSettingsDto {
    timezone?: string | undefined;
    language?: string | undefined;
    profileVisibility?: string | undefined;
    dataSharing?: boolean;
    analyticsOptIn?: boolean;
    searchHistory?: boolean;
    voiceEnabled?: boolean;
    wakeWord?: string | undefined;
    voiceLanguage?: string | undefined;
    voiceSpeed?: number;
    voiceVolume?: number;
    microphoneSensitivity?: number;
    continuousListening?: boolean;
    mascotEnabled?: boolean;
    mascotPersonality?: string | undefined;
    mascotAnimations?: boolean;
    mascotVoice?: boolean;
    mascotProactivity?: number;
    theme?: string | undefined;
    primaryColor?: string | undefined;
    fontSize?: string | undefined;
    reducedMotion?: boolean;
    highContrast?: boolean;
    emailNotifications?: boolean;
    pushNotifications?: boolean;
    achievementNotifications?: boolean;
    weeklyDigest?: boolean;
    maintenanceAlerts?: boolean;
    twoFactorEnabled?: boolean;
    loginAlerts?: boolean;
    sessionTimeout?: number;
    dataEncryption?: boolean;
}

export class VoiceConfigRequest implements IVoiceConfigRequest {
    voiceLanguage?: string | undefined;
    voiceSpeed?: number | undefined;
    voiceVolume?: number | undefined;
    microphoneSensitivity?: number | undefined;
    continuousListening?: boolean | undefined;
    wakeWord?: string | undefined;

    constructor(data?: IVoiceConfigRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.voiceLanguage = _data["voiceLanguage"];
            this.voiceSpeed = _data["voiceSpeed"];
            this.voiceVolume = _data["voiceVolume"];
            this.microphoneSensitivity = _data["microphoneSensitivity"];
            this.continuousListening = _data["continuousListening"];
            this.wakeWord = _data["wakeWord"];
        }
    }

    static fromJS(data: any): VoiceConfigRequest {
        data = typeof data === 'object' ? data : {};
        let result = new VoiceConfigRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["voiceLanguage"] = this.voiceLanguage;
        data["voiceSpeed"] = this.voiceSpeed;
        data["voiceVolume"] = this.voiceVolume;
        data["microphoneSensitivity"] = this.microphoneSensitivity;
        data["continuousListening"] = this.continuousListening;
        data["wakeWord"] = this.wakeWord;
        return data;
    }
}

export interface IVoiceConfigRequest {
    voiceLanguage?: string | undefined;
    voiceSpeed?: number | undefined;
    voiceVolume?: number | undefined;
    microphoneSensitivity?: number | undefined;
    continuousListening?: boolean | undefined;
    wakeWord?: string | undefined;
}

export class VoicePinSetRequest implements IVoicePinSetRequest {
    pin?: string | undefined;
    userId?: string | undefined;

    constructor(data?: IVoicePinSetRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pin = _data["pin"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): VoicePinSetRequest {
        data = typeof data === 'object' ? data : {};
        let result = new VoicePinSetRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pin"] = this.pin;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IVoicePinSetRequest {
    pin?: string | undefined;
    userId?: string | undefined;
}

export class VoicePinSetResponse implements IVoicePinSetResponse {
    success?: boolean;
    message?: string | undefined;

    constructor(data?: IVoicePinSetResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): VoicePinSetResponse {
        data = typeof data === 'object' ? data : {};
        let result = new VoicePinSetResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        return data;
    }
}

export interface IVoicePinSetResponse {
    success?: boolean;
    message?: string | undefined;
}

export class VoicePinVerificationRequest implements IVoicePinVerificationRequest {
    pin?: string | undefined;
    userId?: string | undefined;

    constructor(data?: IVoicePinVerificationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pin = _data["pin"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): VoicePinVerificationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new VoicePinVerificationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pin"] = this.pin;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IVoicePinVerificationRequest {
    pin?: string | undefined;
    userId?: string | undefined;
}

export class VoicePinVerificationResponse implements IVoicePinVerificationResponse {
    isValid?: boolean;
    message?: string | undefined;

    constructor(data?: IVoicePinVerificationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isValid = _data["isValid"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): VoicePinVerificationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new VoicePinVerificationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isValid"] = this.isValid;
        data["message"] = this.message;
        return data;
    }
}

export interface IVoicePinVerificationResponse {
    isValid?: boolean;
    message?: string | undefined;
}

export class VoiceTestRequest implements IVoiceTestRequest {
    text?: string | undefined;

    constructor(data?: IVoiceTestRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): VoiceTestRequest {
        data = typeof data === 'object' ? data : {};
        let result = new VoiceTestRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        return data;
    }
}

export interface IVoiceTestRequest {
    text?: string | undefined;
}

export class VoiceTtsRequest implements IVoiceTtsRequest {
    text?: string | undefined;

    constructor(data?: IVoiceTtsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): VoiceTtsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new VoiceTtsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        return data;
    }
}

export interface IVoiceTtsRequest {
    text?: string | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}